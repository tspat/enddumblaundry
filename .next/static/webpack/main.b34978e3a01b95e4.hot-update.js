"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/@next/react-dev-overlay/lib/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/client.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nexports.__esModule = true;\nexports.onRefresh = exports.unregister = exports.register = exports.onBuildError = exports.onBuildOk = exports.ReactDevOverlay = exports.getNodeError = void 0;\nvar Bus = __importStar(__webpack_require__(/*! ./internal/bus */ \"./node_modules/@next/react-dev-overlay/lib/internal/bus.js\"));\nvar parseStack_1 = __webpack_require__(/*! ./internal/helpers/parseStack */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js\");\nvar isRegistered = false;\nvar stackTraceLimit = undefined;\nfunction onUnhandledError(ev) {\n    var error = ev === null || ev === void 0 ? void 0 : ev.error;\n    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {\n        // A non-error was thrown, we don't have anything to show. :-(\n        return;\n    }\n    var e = error;\n    Bus.emit({\n        type: Bus.TYPE_UNHANDLED_ERROR,\n        reason: error,\n        frames: (0, parseStack_1.parseStack)(e.stack)\n    });\n}\nfunction onUnhandledRejection(ev) {\n    var reason = ev === null || ev === void 0 ? void 0 : ev.reason;\n    if (!reason ||\n        !(reason instanceof Error) ||\n        typeof reason.stack !== 'string') {\n        // A non-error was thrown, we don't have anything to show. :-(\n        return;\n    }\n    var e = reason;\n    Bus.emit({\n        type: Bus.TYPE_UNHANDLED_REJECTION,\n        reason: reason,\n        frames: (0, parseStack_1.parseStack)(e.stack)\n    });\n}\nfunction register() {\n    if (isRegistered) {\n        return;\n    }\n    isRegistered = true;\n    try {\n        var limit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 50;\n        stackTraceLimit = limit;\n    }\n    catch (_a) { }\n    window.addEventListener('error', onUnhandledError);\n    window.addEventListener('unhandledrejection', onUnhandledRejection);\n}\nexports.register = register;\nfunction unregister() {\n    if (!isRegistered) {\n        return;\n    }\n    isRegistered = false;\n    if (stackTraceLimit !== undefined) {\n        try {\n            Error.stackTraceLimit = stackTraceLimit;\n        }\n        catch (_a) { }\n        stackTraceLimit = undefined;\n    }\n    window.removeEventListener('error', onUnhandledError);\n    window.removeEventListener('unhandledrejection', onUnhandledRejection);\n}\nexports.unregister = unregister;\nfunction onBuildOk() {\n    Bus.emit({ type: Bus.TYPE_BUILD_OK });\n}\nexports.onBuildOk = onBuildOk;\nfunction onBuildError(message) {\n    Bus.emit({ type: Bus.TYPE_BUILD_ERROR, message: message });\n}\nexports.onBuildError = onBuildError;\nfunction onRefresh() {\n    Bus.emit({ type: Bus.TYPE_REFFRESH });\n}\nexports.onRefresh = onRefresh;\nvar nodeStackFrames_1 = __webpack_require__(/*! ./internal/helpers/nodeStackFrames */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js\");\n__createBinding(exports, nodeStackFrames_1, \"getNodeError\");\nvar ReactDevOverlay_1 = __webpack_require__(/*! ./internal/ReactDevOverlay */ \"./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js\");\n__createBinding(exports, ReactDevOverlay_1, \"default\", \"ReactDevOverlay\");\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLHVCQUF1QixHQUFHLG9CQUFvQjtBQUNySix1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQStCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBLGlCQUFpQjtBQUNqQix3QkFBd0IsbUJBQU8sQ0FBQywwSEFBb0M7QUFDcEU7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywwR0FBNEI7QUFDNUQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudC5qcz80M2RkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5vblJlZnJlc2ggPSBleHBvcnRzLnVucmVnaXN0ZXIgPSBleHBvcnRzLnJlZ2lzdGVyID0gZXhwb3J0cy5vbkJ1aWxkRXJyb3IgPSBleHBvcnRzLm9uQnVpbGRPayA9IGV4cG9ydHMuUmVhY3REZXZPdmVybGF5ID0gZXhwb3J0cy5nZXROb2RlRXJyb3IgPSB2b2lkIDA7XG52YXIgQnVzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVybmFsL2J1c1wiKSk7XG52YXIgcGFyc2VTdGFja18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrXCIpO1xudmFyIGlzUmVnaXN0ZXJlZCA9IGZhbHNlO1xudmFyIHN0YWNrVHJhY2VMaW1pdCA9IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG9uVW5oYW5kbGVkRXJyb3IoZXYpIHtcbiAgICB2YXIgZXJyb3IgPSBldiA9PT0gbnVsbCB8fCBldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXYuZXJyb3I7XG4gICAgaWYgKCFlcnJvciB8fCAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHx8IHR5cGVvZiBlcnJvci5zdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZSA9IGVycm9yO1xuICAgIEJ1cy5lbWl0KHtcbiAgICAgICAgdHlwZTogQnVzLlRZUEVfVU5IQU5ETEVEX0VSUk9SLFxuICAgICAgICByZWFzb246IGVycm9yLFxuICAgICAgICBmcmFtZXM6ICgwLCBwYXJzZVN0YWNrXzEucGFyc2VTdGFjaykoZS5zdGFjaylcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2KSB7XG4gICAgdmFyIHJlYXNvbiA9IGV2ID09PSBudWxsIHx8IGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldi5yZWFzb247XG4gICAgaWYgKCFyZWFzb24gfHxcbiAgICAgICAgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikgfHxcbiAgICAgICAgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZSA9IHJlYXNvbjtcbiAgICBCdXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IEJ1cy5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT04sXG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICBmcmFtZXM6ICgwLCBwYXJzZVN0YWNrXzEucGFyc2VTdGFjaykoZS5zdGFjaylcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgIGlmIChpc1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gNTA7XG4gICAgICAgIHN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHsgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBvblVuaGFuZGxlZFJlamVjdGlvbik7XG59XG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5mdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgIGlmICghaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgaWYgKHN0YWNrVHJhY2VMaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgc3RhY2tUcmFjZUxpbWl0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvblVuaGFuZGxlZEVycm9yKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xufVxuZXhwb3J0cy51bnJlZ2lzdGVyID0gdW5yZWdpc3RlcjtcbmZ1bmN0aW9uIG9uQnVpbGRPaygpIHtcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX0JVSUxEX09LIH0pO1xufVxuZXhwb3J0cy5vbkJ1aWxkT2sgPSBvbkJ1aWxkT2s7XG5mdW5jdGlvbiBvbkJ1aWxkRXJyb3IobWVzc2FnZSkge1xuICAgIEJ1cy5lbWl0KHsgdHlwZTogQnVzLlRZUEVfQlVJTERfRVJST1IsIG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG59XG5leHBvcnRzLm9uQnVpbGRFcnJvciA9IG9uQnVpbGRFcnJvcjtcbmZ1bmN0aW9uIG9uUmVmcmVzaCgpIHtcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX1JFRkZSRVNIIH0pO1xufVxuZXhwb3J0cy5vblJlZnJlc2ggPSBvblJlZnJlc2g7XG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9oZWxwZXJzL25vZGVTdGFja0ZyYW1lc1wiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBub2RlU3RhY2tGcmFtZXNfMSwgXCJnZXROb2RlRXJyb3JcIik7XG52YXIgUmVhY3REZXZPdmVybGF5XzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9SZWFjdERldk92ZXJsYXlcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgUmVhY3REZXZPdmVybGF5XzEsIFwiZGVmYXVsdFwiLCBcIlJlYWN0RGV2T3ZlcmxheVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/client.js\n");

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nexports.__esModule = true;\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Bus = __importStar(__webpack_require__(/*! ./bus */ \"./node_modules/@next/react-dev-overlay/lib/internal/bus.js\"));\nvar ShadowPortal_1 = __webpack_require__(/*! ./components/ShadowPortal */ \"./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js\");\nvar Errors_1 = __webpack_require__(/*! ./container/Errors */ \"./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js\");\nvar BuildError_1 = __webpack_require__(/*! ./container/BuildError */ \"./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js\");\nvar ErrorBoundary_1 = __webpack_require__(/*! ./ErrorBoundary */ \"./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js\");\nvar Base_1 = __webpack_require__(/*! ./styles/Base */ \"./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js\");\nvar ComponentStyles_1 = __webpack_require__(/*! ./styles/ComponentStyles */ \"./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js\");\nvar CssReset_1 = __webpack_require__(/*! ./styles/CssReset */ \"./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js\");\nfunction reducer(state, ev) {\n    switch (ev.type) {\n        case Bus.TYPE_BUILD_OK: {\n            return __assign(__assign({}, state), { buildError: null });\n        }\n        case Bus.TYPE_BUILD_ERROR: {\n            return __assign(__assign({}, state), { buildError: ev.message });\n        }\n        case Bus.TYPE_REFFRESH: {\n            return __assign(__assign({}, state), { buildError: null, errors: [] });\n        }\n        case Bus.TYPE_UNHANDLED_ERROR:\n        case Bus.TYPE_UNHANDLED_REJECTION: {\n            return __assign(__assign({}, state), { nextId: state.nextId + 1, errors: __spreadArray(__spreadArray([], __read(state.errors), false), [{ id: state.nextId, event: ev }], false) });\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            var _1 = ev;\n            return state;\n        }\n    }\n}\nvar ReactDevOverlay = function ReactDevOverlay(_a) {\n    var children = _a.children;\n    var _b = __read(React.useReducer(reducer, { nextId: 1, buildError: null, errors: [] }), 2), state = _b[0], dispatch = _b[1];\n    React.useEffect(function () {\n        Bus.on(dispatch);\n        return function () {\n            Bus.off(dispatch);\n        };\n    }, [dispatch]);\n    var onComponentError = React.useCallback(function (_error, _componentStack) {\n        // TODO: special handling\n    }, []);\n    var hasBuildError = state.buildError != null;\n    var hasRuntimeErrors = Boolean(state.errors.length);\n    var isMounted = hasBuildError || hasRuntimeErrors;\n    return (React.createElement(React.Fragment, null,\n        React.createElement(ErrorBoundary_1.ErrorBoundary, { onError: onComponentError }, children !== null && children !== void 0 ? children : null),\n        isMounted ? (React.createElement(ShadowPortal_1.ShadowPortal, null,\n            React.createElement(CssReset_1.CssReset, null),\n            React.createElement(Base_1.Base, null),\n            React.createElement(ComponentStyles_1.ComponentStyles, null),\n            hasBuildError ? (React.createElement(BuildError_1.BuildError, { message: state.buildError })) : hasRuntimeErrors ? (React.createElement(Errors_1.Errors, { errors: state.errors })) : undefined)) : undefined));\n};\nexports[\"default\"] = ReactDevOverlay;\n//# sourceMappingURL=ReactDevOverlay.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIseUJBQXlCLG1CQUFPLENBQUMsNENBQU87QUFDeEMsdUJBQXVCLG1CQUFPLENBQUMseUVBQU87QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsaUhBQTJCO0FBQ3hELGVBQWUsbUJBQU8sQ0FBQyxtR0FBb0I7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsMkdBQXdCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLDZGQUFpQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMseUZBQWU7QUFDcEMsd0JBQXdCLG1CQUFPLENBQUMsK0dBQTBCO0FBQzFELGlCQUFpQixtQkFBTyxDQUFDLGlHQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWSxrQkFBa0I7QUFDckU7QUFDQTtBQUNBLHVDQUF1QyxZQUFZLHdCQUF3QjtBQUMzRTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVksOEJBQThCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZLG1HQUFtRyw2QkFBNkIsV0FBVztBQUM5TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5Q0FBeUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwyQkFBMkIsZ0VBQWdFLHNCQUFzQjtBQUM3TDtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheS5qcz8zNTU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEJ1cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9idXNcIikpO1xudmFyIFNoYWRvd1BvcnRhbF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9TaGFkb3dQb3J0YWxcIik7XG52YXIgRXJyb3JzXzEgPSByZXF1aXJlKFwiLi9jb250YWluZXIvRXJyb3JzXCIpO1xudmFyIEJ1aWxkRXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9CdWlsZEVycm9yXCIpO1xudmFyIEVycm9yQm91bmRhcnlfMSA9IHJlcXVpcmUoXCIuL0Vycm9yQm91bmRhcnlcIik7XG52YXIgQmFzZV8xID0gcmVxdWlyZShcIi4vc3R5bGVzL0Jhc2VcIik7XG52YXIgQ29tcG9uZW50U3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ29tcG9uZW50U3R5bGVzXCIpO1xudmFyIENzc1Jlc2V0XzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ3NzUmVzZXRcIik7XG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBldikge1xuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgICBjYXNlIEJ1cy5UWVBFX0JVSUxEX09LOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBidWlsZEVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQnVzLlRZUEVfQlVJTERfRVJST1I6IHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IGJ1aWxkRXJyb3I6IGV2Lm1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBCdXMuVFlQRV9SRUZGUkVTSDoge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZSksIHsgYnVpbGRFcnJvcjogbnVsbCwgZXJyb3JzOiBbXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEJ1cy5UWVBFX1VOSEFORExFRF9FUlJPUjpcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBuZXh0SWQ6IHN0YXRlLm5leHRJZCArIDEsIGVycm9yczogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoc3RhdGUuZXJyb3JzKSwgZmFsc2UpLCBbeyBpZDogc3RhdGUubmV4dElkLCBldmVudDogZXYgfV0sIGZhbHNlKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICB2YXIgXzEgPSBldjtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBSZWFjdERldk92ZXJsYXkgPSBmdW5jdGlvbiBSZWFjdERldk92ZXJsYXkoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlUmVkdWNlcihyZWR1Y2VyLCB7IG5leHRJZDogMSwgYnVpbGRFcnJvcjogbnVsbCwgZXJyb3JzOiBbXSB9KSwgMiksIHN0YXRlID0gX2JbMF0sIGRpc3BhdGNoID0gX2JbMV07XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQnVzLm9uKGRpc3BhdGNoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEJ1cy5vZmYoZGlzcGF0Y2gpO1xuICAgICAgICB9O1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBvbkNvbXBvbmVudEVycm9yID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKF9lcnJvciwgX2NvbXBvbmVudFN0YWNrKSB7XG4gICAgICAgIC8vIFRPRE86IHNwZWNpYWwgaGFuZGxpbmdcbiAgICB9LCBbXSk7XG4gICAgdmFyIGhhc0J1aWxkRXJyb3IgPSBzdGF0ZS5idWlsZEVycm9yICE9IG51bGw7XG4gICAgdmFyIGhhc1J1bnRpbWVFcnJvcnMgPSBCb29sZWFuKHN0YXRlLmVycm9ycy5sZW5ndGgpO1xuICAgIHZhciBpc01vdW50ZWQgPSBoYXNCdWlsZEVycm9yIHx8IGhhc1J1bnRpbWVFcnJvcnM7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnlfMS5FcnJvckJvdW5kYXJ5LCB7IG9uRXJyb3I6IG9uQ29tcG9uZW50RXJyb3IgfSwgY2hpbGRyZW4gIT09IG51bGwgJiYgY2hpbGRyZW4gIT09IHZvaWQgMCA/IGNoaWxkcmVuIDogbnVsbCksXG4gICAgICAgIGlzTW91bnRlZCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFNoYWRvd1BvcnRhbF8xLlNoYWRvd1BvcnRhbCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ3NzUmVzZXRfMS5Dc3NSZXNldCwgbnVsbCksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VfMS5CYXNlLCBudWxsKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50U3R5bGVzXzEuQ29tcG9uZW50U3R5bGVzLCBudWxsKSxcbiAgICAgICAgICAgIGhhc0J1aWxkRXJyb3IgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChCdWlsZEVycm9yXzEuQnVpbGRFcnJvciwgeyBtZXNzYWdlOiBzdGF0ZS5idWlsZEVycm9yIH0pKSA6IGhhc1J1bnRpbWVFcnJvcnMgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvcnNfMS5FcnJvcnMsIHsgZXJyb3JzOiBzdGF0ZS5lcnJvcnMgfSkpIDogdW5kZWZpbmVkKSkgOiB1bmRlZmluZWQpKTtcbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJlYWN0RGV2T3ZlcmxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlYWN0RGV2T3ZlcmxheS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js\n");

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js":
/*!******************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/bus.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexports.__esModule = true;\nexports.off = exports.on = exports.emit = exports.TYPE_UNHANDLED_REJECTION = exports.TYPE_UNHANDLED_ERROR = exports.TYPE_REFFRESH = exports.TYPE_BUILD_ERROR = exports.TYPE_BUILD_OK = void 0;\nexports.TYPE_BUILD_OK = 'build-ok';\nexports.TYPE_BUILD_ERROR = 'build-error';\nexports.TYPE_REFFRESH = 'fast-refresh';\nexports.TYPE_UNHANDLED_ERROR = 'unhandled-error';\nexports.TYPE_UNHANDLED_REJECTION = 'unhandled-rejection';\nvar handlers = new Set();\nvar queue = [];\nfunction drain() {\n    // Draining should never happen synchronously in case multiple handlers are\n    // registered.\n    setTimeout(function () {\n        var _loop_1 = function () {\n            var ev = queue.shift();\n            handlers.forEach(function (handler) { return handler(ev); });\n        };\n        while (\n        // Until we are out of events:\n        Boolean(queue.length) &&\n            // Or, if all handlers removed themselves as a result of handling the\n            // event(s)\n            Boolean(handlers.size)) {\n            _loop_1();\n        }\n    }, 1);\n}\nfunction emit(ev) {\n    queue.push(Object.freeze(__assign({}, ev)));\n    drain();\n}\nexports.emit = emit;\nfunction on(fn) {\n    if (handlers.has(fn)) {\n        return false;\n    }\n    handlers.add(fn);\n    drain();\n    return true;\n}\nexports.on = on;\nfunction off(fn) {\n    if (handlers.has(fn)) {\n        handlers[\"delete\"](fn);\n        return true;\n    }\n    return false;\n}\nexports.off = off;\n//# sourceMappingURL=bus.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2J1cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFdBQVcsR0FBRyxVQUFVLEdBQUcsWUFBWSxHQUFHLGdDQUFnQyxHQUFHLDRCQUE0QixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLHFCQUFxQjtBQUNwTCxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2J1cy5qcz84NGM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLm9mZiA9IGV4cG9ydHMub24gPSBleHBvcnRzLmVtaXQgPSBleHBvcnRzLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTiA9IGV4cG9ydHMuVFlQRV9VTkhBTkRMRURfRVJST1IgPSBleHBvcnRzLlRZUEVfUkVGRlJFU0ggPSBleHBvcnRzLlRZUEVfQlVJTERfRVJST1IgPSBleHBvcnRzLlRZUEVfQlVJTERfT0sgPSB2b2lkIDA7XG5leHBvcnRzLlRZUEVfQlVJTERfT0sgPSAnYnVpbGQtb2snO1xuZXhwb3J0cy5UWVBFX0JVSUxEX0VSUk9SID0gJ2J1aWxkLWVycm9yJztcbmV4cG9ydHMuVFlQRV9SRUZGUkVTSCA9ICdmYXN0LXJlZnJlc2gnO1xuZXhwb3J0cy5UWVBFX1VOSEFORExFRF9FUlJPUiA9ICd1bmhhbmRsZWQtZXJyb3InO1xuZXhwb3J0cy5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT04gPSAndW5oYW5kbGVkLXJlamVjdGlvbic7XG52YXIgaGFuZGxlcnMgPSBuZXcgU2V0KCk7XG52YXIgcXVldWUgPSBbXTtcbmZ1bmN0aW9uIGRyYWluKCkge1xuICAgIC8vIERyYWluaW5nIHNob3VsZCBuZXZlciBoYXBwZW4gc3luY2hyb25vdXNseSBpbiBjYXNlIG11bHRpcGxlIGhhbmRsZXJzIGFyZVxuICAgIC8vIHJlZ2lzdGVyZWQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV2ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIoZXYpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAvLyBVbnRpbCB3ZSBhcmUgb3V0IG9mIGV2ZW50czpcbiAgICAgICAgQm9vbGVhbihxdWV1ZS5sZW5ndGgpICYmXG4gICAgICAgICAgICAvLyBPciwgaWYgYWxsIGhhbmRsZXJzIHJlbW92ZWQgdGhlbXNlbHZlcyBhcyBhIHJlc3VsdCBvZiBoYW5kbGluZyB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50KHMpXG4gICAgICAgICAgICBCb29sZWFuKGhhbmRsZXJzLnNpemUpKSB7XG4gICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgIH1cbiAgICB9LCAxKTtcbn1cbmZ1bmN0aW9uIGVtaXQoZXYpIHtcbiAgICBxdWV1ZS5wdXNoKE9iamVjdC5mcmVlemUoX19hc3NpZ24oe30sIGV2KSkpO1xuICAgIGRyYWluKCk7XG59XG5leHBvcnRzLmVtaXQgPSBlbWl0O1xuZnVuY3Rpb24gb24oZm4pIHtcbiAgICBpZiAoaGFuZGxlcnMuaGFzKGZuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZXJzLmFkZChmbik7XG4gICAgZHJhaW4oKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMub24gPSBvbjtcbmZ1bmN0aW9uIG9mZihmbikge1xuICAgIGlmIChoYW5kbGVycy5oYXMoZm4pKSB7XG4gICAgICAgIGhhbmRsZXJzW1wiZGVsZXRlXCJdKGZuKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMub2ZmID0gb2ZmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/internal/bus.js\n");

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nexports.__esModule = true;\nexports.CodeFrame = void 0;\nvar anser_1 = __importDefault(__webpack_require__(/*! anser */ \"./node_modules/anser/lib/index.js\"));\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ \"./node_modules/strip-ansi/index.js\"));\nvar stack_frame_1 = __webpack_require__(/*! ../../helpers/stack-frame */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js\");\nvar CodeFrame = function CodeFrame(_a) {\n    var stackFrame = _a.stackFrame, codeFrame = _a.codeFrame;\n    // Strip leading spaces out of the code frame:\n    var formattedFrame = React.useMemo(function () {\n        var lines = codeFrame.split(/\\r?\\n/g);\n        var prefixLength = lines\n            .map(function (line) { return /^>? +\\d+ +\\| ( *)/.exec((0, strip_ansi_1[\"default\"])(line)); })\n            .filter(Boolean)\n            .map(function (v) { return v.pop(); })\n            .reduce(function (c, n) { return (isNaN(c) ? n.length : Math.min(c, n.length)); }, NaN);\n        if (prefixLength > 1) {\n            var p_1 = ' '.repeat(prefixLength);\n            return lines\n                .map(function (line, a) {\n                return ~(a = line.indexOf('|'))\n                    ? line.substring(0, a) + line.substring(a).replace(p_1, '')\n                    : line;\n            })\n                .join('\\n');\n        }\n        return lines.join('\\n');\n    }, [codeFrame]);\n    var decoded = React.useMemo(function () {\n        return anser_1[\"default\"].ansiToJson(formattedFrame, {\n            json: true,\n            use_classes: true,\n            remove_empty: true\n        });\n    }, [formattedFrame]);\n    var open = React.useCallback(function () {\n        var _a;\n        var params = new URLSearchParams();\n        for (var key in stackFrame) {\n            params.append(key, ((_a = stackFrame[key]) !== null && _a !== void 0 ? _a : '').toString());\n        }\n        self\n            .fetch(( false || '') + \"/__nextjs_launch-editor?\" + params.toString())\n            .then(function () { }, function () {\n            // TODO: report error\n        });\n    }, [stackFrame]);\n    // TODO: make the caret absolute\n    return (React.createElement(\"div\", { \"data-nextjs-codeframe\": true },\n        React.createElement(\"div\", null,\n            React.createElement(\"p\", { role: \"link\", onClick: open, tabIndex: 1, title: \"Click to open in your editor\" },\n                React.createElement(\"span\", null,\n                    (0, stack_frame_1.getFrameSource)(stackFrame),\n                    \" @ \",\n                    stackFrame.methodName),\n                React.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 24 24\", fill: \"none\", stroke: \"currentColor\", strokeWidth: \"2\", strokeLinecap: \"round\", strokeLinejoin: \"round\" },\n                    React.createElement(\"path\", { d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\" }),\n                    React.createElement(\"polyline\", { points: \"15 3 21 3 21 9\" }),\n                    React.createElement(\"line\", { x1: \"10\", y1: \"14\", x2: \"21\", y2: \"3\" })))),\n        React.createElement(\"pre\", null, decoded.map(function (entry, index) { return (React.createElement(\"span\", { key: \"frame-\" + index, style: __assign({ color: entry.fg ? \"var(--color-\" + entry.fg + \")\" : undefined }, (entry.decoration === 'bold'\n                ? { fontWeight: 800 }\n                : entry.decoration === 'italic'\n                    ? { fontStyle: 'italic' }\n                    : undefined)) }, entry.content)); }))));\n};\nexports.CodeFrame = CodeFrame;\n//# sourceMappingURL=CodeFrame.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL0NvZGVGcmFtZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsOEJBQThCLG1CQUFPLENBQUMsZ0RBQU87QUFDN0MseUJBQXlCLG1CQUFPLENBQUMsNENBQU87QUFDeEMsbUNBQW1DLG1CQUFPLENBQUMsc0RBQVk7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNkdBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzRUFBc0U7QUFDekc7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pELHNDQUFzQyx1REFBdUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQWtDO0FBQ3RELGlDQUFpQztBQUNqQztBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsK0JBQStCO0FBQ3hFO0FBQ0EsdUNBQXVDLGlGQUFpRjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvS0FBb0s7QUFDak4sa0RBQWtELCtEQUErRDtBQUNqSCxzREFBc0QsMEJBQTBCO0FBQ2hGLGtEQUFrRCx1Q0FBdUM7QUFDekYsK0VBQStFLHNDQUFzQyx5Q0FBeUMsK0RBQStEO0FBQzdOLG9CQUFvQjtBQUNwQjtBQUNBLHdCQUF3QjtBQUN4QixtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvQ29kZUZyYW1lLmpzPzlmY2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5Db2RlRnJhbWUgPSB2b2lkIDA7XG52YXIgYW5zZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYW5zZXJcIikpO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgc3RyaXBfYW5zaV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzdHJpcC1hbnNpXCIpKTtcbnZhciBzdGFja19mcmFtZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvc3RhY2stZnJhbWVcIik7XG52YXIgQ29kZUZyYW1lID0gZnVuY3Rpb24gQ29kZUZyYW1lKF9hKSB7XG4gICAgdmFyIHN0YWNrRnJhbWUgPSBfYS5zdGFja0ZyYW1lLCBjb2RlRnJhbWUgPSBfYS5jb2RlRnJhbWU7XG4gICAgLy8gU3RyaXAgbGVhZGluZyBzcGFjZXMgb3V0IG9mIHRoZSBjb2RlIGZyYW1lOlxuICAgIHZhciBmb3JtYXR0ZWRGcmFtZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZXMgPSBjb2RlRnJhbWUuc3BsaXQoL1xccj9cXG4vZyk7XG4gICAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBsaW5lc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gL14+PyArXFxkKyArXFx8ICggKikvLmV4ZWMoKDAsIHN0cmlwX2Fuc2lfMVtcImRlZmF1bHRcIl0pKGxpbmUpKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucG9wKCk7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChjLCBuKSB7IHJldHVybiAoaXNOYU4oYykgPyBuLmxlbmd0aCA6IE1hdGgubWluKGMsIG4ubGVuZ3RoKSk7IH0sIE5hTik7XG4gICAgICAgIGlmIChwcmVmaXhMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgcF8xID0gJyAnLnJlcGVhdChwcmVmaXhMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSwgYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB+KGEgPSBsaW5lLmluZGV4T2YoJ3wnKSlcbiAgICAgICAgICAgICAgICAgICAgPyBsaW5lLnN1YnN0cmluZygwLCBhKSArIGxpbmUuc3Vic3RyaW5nKGEpLnJlcGxhY2UocF8xLCAnJylcbiAgICAgICAgICAgICAgICAgICAgOiBsaW5lO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH0sIFtjb2RlRnJhbWVdKTtcbiAgICB2YXIgZGVjb2RlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW5zZXJfMVtcImRlZmF1bHRcIl0uYW5zaVRvSnNvbihmb3JtYXR0ZWRGcmFtZSwge1xuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sIFtmb3JtYXR0ZWRGcmFtZV0pO1xuICAgIHZhciBvcGVuID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgKChfYSA9IHN0YWNrRnJhbWVba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGZcbiAgICAgICAgICAgIC5mZXRjaCgocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJykgKyBcIi9fX25leHRqc19sYXVuY2gtZWRpdG9yP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcG9ydCBlcnJvclxuICAgICAgICB9KTtcbiAgICB9LCBbc3RhY2tGcmFtZV0pO1xuICAgIC8vIFRPRE86IG1ha2UgdGhlIGNhcmV0IGFic29sdXRlXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1jb2RlZnJhbWVcIjogdHJ1ZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7IHJvbGU6IFwibGlua1wiLCBvbkNsaWNrOiBvcGVuLCB0YWJJbmRleDogMSwgdGl0bGU6IFwiQ2xpY2sgdG8gb3BlbiBpbiB5b3VyIGVkaXRvclwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgKDAsIHN0YWNrX2ZyYW1lXzEuZ2V0RnJhbWVTb3VyY2UpKHN0YWNrRnJhbWUpLFxuICAgICAgICAgICAgICAgICAgICBcIiBAIFwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFja0ZyYW1lLm1ldGhvZE5hbWUpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE1IDMgMjEgMyAyMSA5XCIgfSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTBcIiwgeTE6IFwiMTRcIiwgeDI6IFwiMjFcIiwgeTI6IFwiM1wiIH0pKSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIG51bGwsIGRlY29kZWQubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGtleTogXCJmcmFtZS1cIiArIGluZGV4LCBzdHlsZTogX19hc3NpZ24oeyBjb2xvcjogZW50cnkuZmcgPyBcInZhcigtLWNvbG9yLVwiICsgZW50cnkuZmcgKyBcIilcIiA6IHVuZGVmaW5lZCB9LCAoZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2JvbGQnXG4gICAgICAgICAgICAgICAgPyB7IGZvbnRXZWlnaHQ6IDgwMCB9XG4gICAgICAgICAgICAgICAgOiBlbnRyeS5kZWNvcmF0aW9uID09PSAnaXRhbGljJ1xuICAgICAgICAgICAgICAgICAgICA/IHsgZm9udFN0eWxlOiAnaXRhbGljJyB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSkgfSwgZW50cnkuY29udGVudCkpOyB9KSkpKTtcbn07XG5leHBvcnRzLkNvZGVGcmFtZSA9IENvZGVGcmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvZGVGcmFtZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js\n");

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n    return cooked;\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nexports.__esModule = true;\nexports.RuntimeError = exports.styles = void 0;\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar CodeFrame_1 = __webpack_require__(/*! ../components/CodeFrame */ \"./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js\");\nvar noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js\");\nvar stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js\");\nvar CallStackFrame = function CallStackFrame(_a) {\n    // TODO: ability to expand resolved frames\n    // TODO: render error or external indicator\n    var _b;\n    var frame = _a.frame;\n    var f = (_b = frame.originalStackFrame) !== null && _b !== void 0 ? _b : frame.sourceStackFrame;\n    var hasSource = Boolean(frame.originalCodeFrame);\n    var open = React.useCallback(function () {\n        var _a;\n        if (!hasSource)\n            return;\n        var params = new URLSearchParams();\n        for (var key in f) {\n            params.append(key, ((_a = f[key]) !== null && _a !== void 0 ? _a : '').toString());\n        }\n        self\n            .fetch(( false || '') + \"/__nextjs_launch-editor?\" + params.toString())\n            .then(function () { }, function () {\n            // TODO: report error\n        });\n    }, [hasSource, f]);\n    return (React.createElement(\"div\", { \"data-nextjs-call-stack-frame\": true },\n        React.createElement(\"h6\", { \"data-nextjs-frame-expanded\": Boolean(frame.expanded) }, f.methodName),\n        React.createElement(\"div\", { \"data-has-source\": hasSource ? 'true' : undefined, tabIndex: hasSource ? 10 : undefined, role: hasSource ? 'link' : undefined, onClick: open, title: hasSource ? 'Click to open in your editor' : undefined },\n            React.createElement(\"span\", null, (0, stack_frame_1.getFrameSource)(f)),\n            React.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 24 24\", fill: \"none\", stroke: \"currentColor\", strokeWidth: \"2\", strokeLinecap: \"round\", strokeLinejoin: \"round\" },\n                React.createElement(\"path\", { d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\" }),\n                React.createElement(\"polyline\", { points: \"15 3 21 3 21 9\" }),\n                React.createElement(\"line\", { x1: \"10\", y1: \"14\", x2: \"21\", y2: \"3\" })))));\n};\nvar RuntimeError = function RuntimeError(_a) {\n    var error = _a.error;\n    var firstFirstPartyFrameIndex = React.useMemo(function () {\n        return error.frames.findIndex(function (entry) {\n            return entry.expanded &&\n                Boolean(entry.originalCodeFrame) &&\n                Boolean(entry.originalStackFrame);\n        });\n    }, [error.frames]);\n    var firstFrame = React.useMemo(function () {\n        var _a;\n        return (_a = error.frames[firstFirstPartyFrameIndex]) !== null && _a !== void 0 ? _a : null;\n    }, [error.frames, firstFirstPartyFrameIndex]);\n    var allLeadingFrames = React.useMemo(function () {\n        return firstFirstPartyFrameIndex < 0\n            ? []\n            : error.frames.slice(0, firstFirstPartyFrameIndex);\n    }, [error.frames, firstFirstPartyFrameIndex]);\n    var _b = __read(React.useState(firstFrame == null), 2), all = _b[0], setAll = _b[1];\n    var toggleAll = React.useCallback(function () {\n        setAll(function (v) { return !v; });\n    }, []);\n    var leadingFrames = React.useMemo(function () { return allLeadingFrames.filter(function (f) { return f.expanded || all; }); }, [all, allLeadingFrames]);\n    var allCallStackFrames = React.useMemo(function () { return error.frames.slice(firstFirstPartyFrameIndex + 1); }, [error.frames, firstFirstPartyFrameIndex]);\n    var visibleCallStackFrames = React.useMemo(function () { return allCallStackFrames.filter(function (f) { return f.expanded || all; }); }, [all, allCallStackFrames]);\n    var canShowMore = React.useMemo(function () {\n        return (allCallStackFrames.length !== visibleCallStackFrames.length ||\n            (all && firstFrame != null));\n    }, [\n        all,\n        allCallStackFrames.length,\n        firstFrame,\n        visibleCallStackFrames.length,\n    ]);\n    return (React.createElement(React.Fragment, null,\n        firstFrame ? (React.createElement(React.Fragment, null,\n            React.createElement(\"h5\", null, \"Source\"),\n            leadingFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: \"leading-frame-\" + index + \"-\" + all, frame: frame })); }),\n            React.createElement(CodeFrame_1.CodeFrame, { stackFrame: firstFrame.originalStackFrame, codeFrame: firstFrame.originalCodeFrame }))) : undefined,\n        visibleCallStackFrames.length ? (React.createElement(React.Fragment, null,\n            React.createElement(\"h5\", null, \"Call Stack\"),\n            visibleCallStackFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: \"call-stack-\" + index + \"-\" + all, frame: frame })); }))) : undefined,\n        canShowMore ? (React.createElement(React.Fragment, null,\n            React.createElement(\"button\", { tabIndex: 10, \"data-nextjs-data-runtime-error-collapsed-action\": true, type: \"button\", onClick: toggleAll },\n                all ? 'Hide' : 'Show',\n                \" collapsed frames\"))) : undefined));\n};\nexports.RuntimeError = RuntimeError;\nexports.styles = (0, noop_template_1.noop)(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\\n  button[data-nextjs-data-runtime-error-collapsed-action] {\\n    background: none;\\n    border: none;\\n    padding: 0;\\n    font-size: var(--size-font-small);\\n    line-height: var(--size-font-bigger);\\n    color: var(--color-accents-3);\\n  }\\n\\n  [data-nextjs-call-stack-frame]:not(:last-child) {\\n    margin-bottom: var(--size-gap-double);\\n  }\\n\\n  [data-nextjs-call-stack-frame] > h6 {\\n    margin-top: 0;\\n    margin-bottom: var(--size-gap);\\n    font-family: var(--font-stack-monospace);\\n    color: #222;\\n  }\\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\\n    color: #666;\\n  }\\n  [data-nextjs-call-stack-frame] > div {\\n    display: flex;\\n    align-items: center;\\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\\n    font-size: var(--size-font-small);\\n    color: #999;\\n  }\\n  [data-nextjs-call-stack-frame] > div > svg {\\n    width: auto;\\n    height: var(--size-font-small);\\n    margin-left: var(--size-gap);\\n\\n    display: none;\\n  }\\n\\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\\n    cursor: pointer;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\\n    display: unset;\\n  }\\n\"], [\"\\n  button[data-nextjs-data-runtime-error-collapsed-action] {\\n    background: none;\\n    border: none;\\n    padding: 0;\\n    font-size: var(--size-font-small);\\n    line-height: var(--size-font-bigger);\\n    color: var(--color-accents-3);\\n  }\\n\\n  [data-nextjs-call-stack-frame]:not(:last-child) {\\n    margin-bottom: var(--size-gap-double);\\n  }\\n\\n  [data-nextjs-call-stack-frame] > h6 {\\n    margin-top: 0;\\n    margin-bottom: var(--size-gap);\\n    font-family: var(--font-stack-monospace);\\n    color: #222;\\n  }\\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\\n    color: #666;\\n  }\\n  [data-nextjs-call-stack-frame] > div {\\n    display: flex;\\n    align-items: center;\\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\\n    font-size: var(--size-font-small);\\n    color: #999;\\n  }\\n  [data-nextjs-call-stack-frame] > div > svg {\\n    width: auto;\\n    height: var(--size-font-small);\\n    margin-left: var(--size-gap);\\n\\n    display: none;\\n  }\\n\\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\\n    cursor: pointer;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\\n    display: unset;\\n  }\\n\"])));\nvar templateObject_1;\n//# sourceMappingURL=RuntimeError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsb0JBQW9CLEdBQUcsY0FBYztBQUNyQyx5QkFBeUIsbUJBQU8sQ0FBQyw0Q0FBTztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxrSEFBeUI7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsOEdBQTBCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLDBHQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFrQztBQUN0RCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLHlDQUF5QyxzQ0FBc0M7QUFDL0Usb0NBQW9DLHVEQUF1RDtBQUMzRixxQ0FBcUMsNk1BQTZNO0FBQ2xQO0FBQ0EseUNBQXlDLG9LQUFvSztBQUM3TSw4Q0FBOEMsK0RBQStEO0FBQzdHLGtEQUFrRCwwQkFBMEI7QUFDNUUsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDLEtBQUs7QUFDTCxvREFBb0QsOENBQThDLDJCQUEyQixJQUFJO0FBQ2pJLHlEQUF5RCwyREFBMkQ7QUFDcEgsNkRBQTZELGdEQUFnRCwyQkFBMkIsSUFBSTtBQUM1STtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw4Q0FBOEMseURBQXlELEtBQUs7QUFDcEsseURBQXlELG9GQUFvRjtBQUM3STtBQUNBO0FBQ0EsaUVBQWlFLDhDQUE4QyxzREFBc0QsS0FBSztBQUMxSztBQUNBLDRDQUE0QywyR0FBMkc7QUFDdko7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGNBQWMseUpBQXlKLHVCQUF1QixtQkFBbUIsaUJBQWlCLHdDQUF3QywyQ0FBMkMsb0NBQW9DLEtBQUssdURBQXVELDRDQUE0QyxLQUFLLDJDQUEyQyxvQkFBb0IscUNBQXFDLCtDQUErQyxrQkFBa0IsS0FBSyw2RUFBNkUsa0JBQWtCLEtBQUssMENBQTBDLG9CQUFvQiwwQkFBMEIsaUVBQWlFLHdDQUF3QyxrQkFBa0IsS0FBSyxnREFBZ0Qsa0JBQWtCLHFDQUFxQyxtQ0FBbUMsc0JBQXNCLEtBQUssNkRBQTZELHNCQUFzQixLQUFLLGlFQUFpRSx3Q0FBd0MsS0FBSyxpRUFBaUUscUJBQXFCLEtBQUsscUVBQXFFLHVCQUF1QixtQkFBbUIsaUJBQWlCLHdDQUF3QywyQ0FBMkMsb0NBQW9DLEtBQUssdURBQXVELDRDQUE0QyxLQUFLLDJDQUEyQyxvQkFBb0IscUNBQXFDLCtDQUErQyxrQkFBa0IsS0FBSyw2RUFBNkUsa0JBQWtCLEtBQUssMENBQTBDLG9CQUFvQiwwQkFBMEIsaUVBQWlFLHdDQUF3QyxrQkFBa0IsS0FBSyxnREFBZ0Qsa0JBQWtCLHFDQUFxQyxtQ0FBbUMsc0JBQXNCLEtBQUssNkRBQTZELHNCQUFzQixLQUFLLGlFQUFpRSx3Q0FBd0MsS0FBSyxpRUFBaUUscUJBQXFCLEtBQUs7QUFDbG9GO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb250YWluZXIvUnVudGltZUVycm9yLmpzP2MyMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5SdW50aW1lRXJyb3IgPSBleHBvcnRzLnN0eWxlcyA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lXCIpO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xudmFyIENhbGxTdGFja0ZyYW1lID0gZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoX2EpIHtcbiAgICAvLyBUT0RPOiBhYmlsaXR5IHRvIGV4cGFuZCByZXNvbHZlZCBmcmFtZXNcbiAgICAvLyBUT0RPOiByZW5kZXIgZXJyb3Igb3IgZXh0ZXJuYWwgaW5kaWNhdG9yXG4gICAgdmFyIF9iO1xuICAgIHZhciBmcmFtZSA9IF9hLmZyYW1lO1xuICAgIHZhciBmID0gKF9iID0gZnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmcmFtZS5zb3VyY2VTdGFja0ZyYW1lO1xuICAgIHZhciBoYXNTb3VyY2UgPSBCb29sZWFuKGZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lKTtcbiAgICB2YXIgb3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWhhc1NvdXJjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGYpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCAoKF9hID0gZltrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZlxuICAgICAgICAgICAgLmZldGNoKChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnKSArIFwiL19fbmV4dGpzX2xhdW5jaC1lZGl0b3I/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwb3J0IGVycm9yXG4gICAgICAgIH0pO1xuICAgIH0sIFtoYXNTb3VyY2UsIGZdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVcIjogdHJ1ZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDZcIiwgeyBcImRhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkXCI6IEJvb2xlYW4oZnJhbWUuZXhwYW5kZWQpIH0sIGYubWV0aG9kTmFtZSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtaGFzLXNvdXJjZVwiOiBoYXNTb3VyY2UgPyAndHJ1ZScgOiB1bmRlZmluZWQsIHRhYkluZGV4OiBoYXNTb3VyY2UgPyAxMCA6IHVuZGVmaW5lZCwgcm9sZTogaGFzU291cmNlID8gJ2xpbmsnIDogdW5kZWZpbmVkLCBvbkNsaWNrOiBvcGVuLCB0aXRsZTogaGFzU291cmNlID8gJ0NsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3InIDogdW5kZWZpbmVkIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCAoMCwgc3RhY2tfZnJhbWVfMS5nZXRGcmFtZVNvdXJjZSkoZikpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xOCAxM3Y2YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmg2XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE1IDMgMjEgMyAyMSA5XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgeyB4MTogXCIxMFwiLCB5MTogXCIxNFwiLCB4MjogXCIyMVwiLCB5MjogXCIzXCIgfSkpKSkpO1xufTtcbnZhciBSdW50aW1lRXJyb3IgPSBmdW5jdGlvbiBSdW50aW1lRXJyb3IoX2EpIHtcbiAgICB2YXIgZXJyb3IgPSBfYS5lcnJvcjtcbiAgICB2YXIgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3IuZnJhbWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5leHBhbmRlZCAmJlxuICAgICAgICAgICAgICAgIEJvb2xlYW4oZW50cnkub3JpZ2luYWxDb2RlRnJhbWUpICYmXG4gICAgICAgICAgICAgICAgQm9vbGVhbihlbnRyeS5vcmlnaW5hbFN0YWNrRnJhbWUpO1xuICAgICAgICB9KTtcbiAgICB9LCBbZXJyb3IuZnJhbWVzXSk7XG4gICAgdmFyIGZpcnN0RnJhbWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gZXJyb3IuZnJhbWVzW2ZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH0sIFtlcnJvci5mcmFtZXMsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKTtcbiAgICB2YXIgYWxsTGVhZGluZ0ZyYW1lcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA8IDBcbiAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgIDogZXJyb3IuZnJhbWVzLnNsaWNlKDAsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXgpO1xuICAgIH0sIFtlcnJvci5mcmFtZXMsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoZmlyc3RGcmFtZSA9PSBudWxsKSwgMiksIGFsbCA9IF9iWzBdLCBzZXRBbGwgPSBfYlsxXTtcbiAgICB2YXIgdG9nZ2xlQWxsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRBbGwoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICF2OyB9KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGxlYWRpbmdGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsbExlYWRpbmdGcmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmV4cGFuZGVkIHx8IGFsbDsgfSk7IH0sIFthbGwsIGFsbExlYWRpbmdGcmFtZXNdKTtcbiAgICB2YXIgYWxsQ2FsbFN0YWNrRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvci5mcmFtZXMuc2xpY2UoZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCArIDEpOyB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XG4gICAgdmFyIHZpc2libGVDYWxsU3RhY2tGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsbENhbGxTdGFja0ZyYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuZXhwYW5kZWQgfHwgYWxsOyB9KTsgfSwgW2FsbCwgYWxsQ2FsbFN0YWNrRnJhbWVzXSk7XG4gICAgdmFyIGNhblNob3dNb3JlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoYWxsQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCAhPT0gdmlzaWJsZUNhbGxTdGFja0ZyYW1lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIChhbGwgJiYgZmlyc3RGcmFtZSAhPSBudWxsKSk7XG4gICAgfSwgW1xuICAgICAgICBhbGwsXG4gICAgICAgIGFsbENhbGxTdGFja0ZyYW1lcy5sZW5ndGgsXG4gICAgICAgIGZpcnN0RnJhbWUsXG4gICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoLFxuICAgIF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgZmlyc3RGcmFtZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg1XCIsIG51bGwsIFwiU291cmNlXCIpLFxuICAgICAgICAgICAgbGVhZGluZ0ZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lLCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFN0YWNrRnJhbWUsIHsga2V5OiBcImxlYWRpbmctZnJhbWUtXCIgKyBpbmRleCArIFwiLVwiICsgYWxsLCBmcmFtZTogZnJhbWUgfSkpOyB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZUZyYW1lXzEuQ29kZUZyYW1lLCB7IHN0YWNrRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lLCBjb2RlRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxDb2RlRnJhbWUgfSkpKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdmlzaWJsZUNhbGxTdGFja0ZyYW1lcy5sZW5ndGggPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNVwiLCBudWxsLCBcIkNhbGwgU3RhY2tcIiksXG4gICAgICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLm1hcChmdW5jdGlvbiAoZnJhbWUsIGluZGV4KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDYWxsU3RhY2tGcmFtZSwgeyBrZXk6IFwiY2FsbC1zdGFjay1cIiArIGluZGV4ICsgXCItXCIgKyBhbGwsIGZyYW1lOiBmcmFtZSB9KSk7IH0pKSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGNhblNob3dNb3JlID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdGFiSW5kZXg6IDEwLCBcImRhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXCI6IHRydWUsIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IHRvZ2dsZUFsbCB9LFxuICAgICAgICAgICAgICAgIGFsbCA/ICdIaWRlJyA6ICdTaG93JyxcbiAgICAgICAgICAgICAgICBcIiBjb2xsYXBzZWQgZnJhbWVzXCIpKSkgOiB1bmRlZmluZWQpKTtcbn07XG5leHBvcnRzLlJ1bnRpbWVFcnJvciA9IFJ1bnRpbWVFcnJvcjtcbmV4cG9ydHMuc3R5bGVzID0gKDAsIG5vb3BfdGVtcGxhdGVfMS5ub29wKSh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBidXR0b25bZGF0YS1uZXh0anMtZGF0YS1ydW50aW1lLWVycm9yLWNvbGxhcHNlZC1hY3Rpb25dIHtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMyk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV06bm90KDpsYXN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoNiB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgY29sb3I6ICMyMjI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoNltkYXRhLW5leHRqcy1mcmFtZS1leHBhbmRlZD0nZmFsc2UnXSB7XFxuICAgIGNvbG9yOiAjNjY2O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZy1sZWZ0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBjb2xvcjogIzk5OTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcCk7XFxuXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0gPiBzdmcge1xcbiAgICBkaXNwbGF5OiB1bnNldDtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdKSkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SdW50aW1lRXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = connect;\n\nvar _client = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\");\n\nvar _stripAnsi = _interopRequireDefault(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\"));\n\nvar _websocket = __webpack_require__(/*! ./websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\n\nvar _formatWebpackMessages = _interopRequireDefault(__webpack_require__(/*! ./format-webpack-messages */ \"./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js\"));\n\nvar _router = _interopRequireDefault(__webpack_require__(/*! next/router */ \"./node_modules/next/router.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n} // This alternative WebpackDevServer combines the functionality of:\n// https://github.com/webpack/webpack-dev-server/blob/webpack-1/client/index.js\n// https://github.com/webpack/webpack/blob/webpack-1/hot/dev-server.js\n// It only supports their simplest configuration (hot updates on same server).\n// It makes some opinionated choices on top, like adding a syntax error overlay\n// that looks similar to our console output. The error overlay is inspired by:\n// https://github.com/glenjamin/webpack-hot-middleware\n\n\nvar hadRuntimeError = false;\nvar customHmrEventHandler;\n\nfunction connect() {\n  (0, _client).register();\n  (0, _websocket).addMessageListener(function (event) {\n    if (event.data.indexOf('action') === -1) return;\n\n    try {\n      processMessage(event);\n    } catch (ex) {\n      console.warn('Invalid HMR message: ' + event.data + '\\n' + ex);\n    }\n  });\n  return {\n    subscribeToHmrEvent: function subscribeToHmrEvent(handler) {\n      customHmrEventHandler = handler;\n    },\n    onUnrecoverableError: function onUnrecoverableError() {\n      hadRuntimeError = true;\n    }\n  };\n} // Remember some state related to hot module replacement.\n\n\nvar isFirstCompilation = true;\nvar mostRecentCompilationHash = null;\nvar hasCompileErrors = false;\n\nfunction clearOutdatedErrors() {\n  // Clean up outdated compile errors, if any.\n  if (typeof console !== 'undefined' && typeof console.clear === 'function') {\n    if (hasCompileErrors) {\n      console.clear();\n    }\n  }\n} // Successful compilation.\n\n\nfunction handleSuccess() {\n  clearOutdatedErrors();\n  var isHotUpdate = !isFirstCompilation || _router[\"default\"].pathname !== '/_error' && isUpdateAvailable();\n  isFirstCompilation = false;\n  hasCompileErrors = false; // Attempt to apply hot updates or reload.\n\n  if (isHotUpdate) {\n    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {\n      // Only dismiss it when we're sure it's a hot update.\n      // Otherwise it would flicker right before the reload.\n      onFastRefresh(hasUpdates);\n    });\n  }\n} // Compilation with warnings (e.g. ESLint).\n\n\nfunction handleWarnings(warnings) {\n  clearOutdatedErrors();\n  var isHotUpdate = !isFirstCompilation;\n  isFirstCompilation = false;\n  hasCompileErrors = false;\n\n  function printWarnings() {\n    // Print warnings to the console.\n    var formatted = (0, _formatWebpackMessages)[\"default\"]({\n      warnings: warnings,\n      errors: []\n    });\n\n    if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      for (var i = 0; i < formatted.warnings.length; i++) {\n        if (i === 5) {\n          console.warn('There were more warnings in other files.\\n' + 'You can find a complete log in the terminal.');\n          break;\n        }\n\n        console.warn((0, _stripAnsi)[\"default\"](formatted.warnings[i]));\n      }\n    }\n  }\n\n  printWarnings(); // Attempt to apply hot updates or reload.\n\n  if (isHotUpdate) {\n    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {\n      // Only dismiss it when we're sure it's a hot update.\n      // Otherwise it would flicker right before the reload.\n      onFastRefresh(hasUpdates);\n    });\n  }\n} // Compilation with errors (e.g. syntax error or missing modules).\n\n\nfunction handleErrors(errors) {\n  clearOutdatedErrors();\n  isFirstCompilation = false;\n  hasCompileErrors = true; // \"Massage\" webpack messages.\n\n  var formatted = (0, _formatWebpackMessages)[\"default\"]({\n    errors: errors,\n    warnings: []\n  }); // Only show the first error.\n\n  (0, _client).onBuildError(formatted.errors[0]); // Also log them to the console.\n\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    for (var i = 0; i < formatted.errors.length; i++) {\n      console.error((0, _stripAnsi)[\"default\"](formatted.errors[i]));\n    }\n  } // Do not attempt to reload now.\n  // We will reload on next success instead.\n\n\n  if (undefined) {\n    if (self.__NEXT_HMR_CB) {\n      self.__NEXT_HMR_CB(formatted.errors[0]);\n\n      self.__NEXT_HMR_CB = null;\n    }\n  }\n}\n\nvar startLatency = undefined;\n\nfunction onFastRefresh(hasUpdates) {\n  (0, _client).onBuildOk();\n\n  if (hasUpdates) {\n    (0, _client).onRefresh();\n  }\n\n  if (startLatency) {\n    var latency = Date.now() - startLatency;\n    console.log(\"[Fast Refresh] done in \".concat(latency, \"ms\"));\n\n    if (self.__NEXT_HMR_LATENCY_CB) {\n      self.__NEXT_HMR_LATENCY_CB(latency);\n    }\n  }\n} // There is a newer version of the code available.\n\n\nfunction handleAvailableHash(hash) {\n  // Update last known compilation hash.\n  mostRecentCompilationHash = hash;\n} // Handle messages from the server.\n\n\nfunction processMessage(e) {\n  var obj = JSON.parse(e.data);\n\n  switch (obj.action) {\n    case 'building':\n      {\n        startLatency = Date.now();\n        console.log('[Fast Refresh] rebuilding');\n        break;\n      }\n\n    case 'built':\n    case 'sync':\n      {\n        if (obj.hash) {\n          handleAvailableHash(obj.hash);\n        }\n\n        var errors = obj.errors,\n            warnings = obj.warnings;\n        var hasErrors = Boolean(errors && errors.length);\n\n        if (hasErrors) {\n          return handleErrors(errors);\n        }\n\n        var hasWarnings = Boolean(warnings && warnings.length);\n\n        if (hasWarnings) {\n          return handleWarnings(warnings);\n        }\n\n        return handleSuccess();\n      }\n\n    default:\n      {\n        if (customHmrEventHandler) {\n          customHmrEventHandler(obj);\n          break;\n        }\n\n        break;\n      }\n  }\n} // Is there a newer version of this code available?\n\n\nfunction isUpdateAvailable() {\n  /* globals __webpack_hash__ */\n  // __webpack_hash__ is the hash of the current compilation.\n  // It's a global variable injected by Webpack.\n  return mostRecentCompilationHash !== __webpack_require__.h();\n} // Webpack disallows updates in other states.\n\n\nfunction canApplyUpdates() {\n  return module.hot.status() === 'idle';\n}\n\nfunction afterApplyUpdates(fn) {\n  if (canApplyUpdates()) {\n    fn();\n  } else {\n    var handler = function handler(status) {\n      if (status === 'idle') {\n        module.hot.removeStatusHandler(handler);\n        fn();\n      }\n    };\n\n    module.hot.addStatusHandler(handler);\n  }\n} // Attempt to update code on the fly, fall back to a hard reload.\n\n\nfunction tryApplyUpdates(onHotUpdateSuccess) {\n  if (false) {}\n\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    (0, _client).onBuildOk();\n    return;\n  }\n\n  function handleApplyUpdates(err, updatedModules) {\n    if (err || hadRuntimeError || !updatedModules) {\n      if (err) {\n        console.warn('[Fast Refresh] performing full reload\\n\\n' + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' + 'Fast Refresh requires at least one parent function component in your React tree.');\n      } else if (hadRuntimeError) {\n        console.warn('[Fast Refresh] performing full reload because your application had an unrecoverable error');\n      }\n\n      window.location.reload();\n      return;\n    }\n\n    var hasUpdates = Boolean(updatedModules.length);\n\n    if (typeof onHotUpdateSuccess === 'function') {\n      // Maybe we want to do something.\n      onHotUpdateSuccess(hasUpdates);\n    }\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdates(hasUpdates ? _client.onBuildOk : onHotUpdateSuccess);\n    } else {\n      (0, _client).onBuildOk();\n\n      if (undefined) {\n        afterApplyUpdates(function () {\n          if (self.__NEXT_HMR_CB) {\n            self.__NEXT_HMR_CB();\n\n            self.__NEXT_HMR_CB = null;\n          }\n        });\n      }\n    }\n  } // https://webpack.js.org/api/hot-module-replacement/#check\n\n\n  module.hot.check(\n  /* autoApply */\n  true).then(function (updatedModules) {\n    handleApplyUpdates(null, updatedModules);\n  }, function (err) {\n    handleApplyUpdates(err, null);\n  });\n}\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBQ2JBLDhDQUE2QztBQUN6Q0csRUFBQUEsS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELGtCQUFBLEdBQWtCRSxPQUFsQjs7QUFDQSxJQUFJQyxPQUFPLEdBQUdDLG1CQUFPLENBQUMsZ0dBQUQsQ0FBckI7O0FBQ0EsSUFBSUMsVUFBVSxHQUFHQyxzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyw0RkFBRCxDQUFSLENBQXZDOztBQUNBLElBQUlHLFVBQVUsR0FBR0gsbUJBQU8sQ0FBQyxtRkFBRCxDQUF4Qjs7QUFDQSxJQUFJSSxzQkFBc0IsR0FBR0Ysc0JBQXNCLENBQUNGLG1CQUFPLENBQUMsK0dBQUQsQ0FBUixDQUFuRDs7QUFDQSxJQUFJSyxPQUFPLEdBQUdILHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLGtEQUFELENBQVIsQ0FBcEM7O0FBQ0EsU0FBU0Usc0JBQVQsQ0FBZ0NJLEdBQWhDLEVBQXFDO0FBQ2pDLFNBQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYLEdBQXdCRCxHQUF4QixHQUE4QjtBQUNqQyxlQUFTQTtBQUR3QixHQUFyQztBQUdILEVBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLElBQUlFLGVBQWUsR0FBRyxLQUF0QjtBQUNBLElBQUlDLHFCQUFKOztBQUNBLFNBQVNYLE9BQVQsR0FBbUI7QUFDZixHQUFDLEdBQUdDLE9BQUosRUFBYVcsUUFBYjtBQUNBLEdBQUMsR0FBR1AsVUFBSixFQUFnQlEsa0JBQWhCLENBQW1DLFVBQUNDLEtBQUQsRUFBUztBQUN4QyxRQUFJQSxLQUFLLENBQUNDLElBQU4sQ0FBV0MsT0FBWCxDQUFtQixRQUFuQixNQUFpQyxDQUFDLENBQXRDLEVBQXlDOztBQUN6QyxRQUFJO0FBQ0FDLE1BQUFBLGNBQWMsQ0FBQ0gsS0FB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RCxZQUFBQSxJQUFJLENBQUNDLGFBQUw7O0FBQ0FELFlBQUFBLElBQUksQ0FBQ0MsYUFBTCxHQUFxQixJQUFyQjtBQUNIO0FBQ0osU0FMZ0IsQ0FBakI7QUFNSDtBQUNKO0FBQ0osR0F4Q3dDLENBeUN6Qzs7O0FBQ0FxQixFQUFBQSxVQUFBLENBQVdjLEtBQVg7QUFBaUI7QUFBZ0IsTUFBakMsRUFBdUNDLElBQXZDLENBQTRDLFVBQUNMLGNBQUQsRUFBa0I7QUFDMURGLElBQUFBLGtCQUFrQixDQUFDLElBQUQsRUFBT0UsY0FBUCxDQUFsQjtBQUNILEdBRkQsRUFFRyxVQUFDRCxHQUFELEVBQU87QUFDTkQsSUFBQUEsa0JBQWtCLENBQUNDLEdBQUQsRUFBTSxJQUFOLENBQWxCO0FBQ0gsR0FKRDtBQUtIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2hvdC1kZXYtY2xpZW50LmpzPzE2MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjb25uZWN0O1xudmFyIF9jbGllbnQgPSByZXF1aXJlKFwiQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudFwiKTtcbnZhciBfc3RyaXBBbnNpID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2lcIikpO1xudmFyIF93ZWJzb2NrZXQgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXRcIik7XG52YXIgX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZm9ybWF0LXdlYnBhY2stbWVzc2FnZXNcIikpO1xudmFyIF9yb3V0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG4vLyBUaGlzIGFsdGVybmF0aXZlIFdlYnBhY2tEZXZTZXJ2ZXIgY29tYmluZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2Y6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvYmxvYi93ZWJwYWNrLTEvY2xpZW50L2luZGV4LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2Ivd2VicGFjay0xL2hvdC9kZXYtc2VydmVyLmpzXG4vLyBJdCBvbmx5IHN1cHBvcnRzIHRoZWlyIHNpbXBsZXN0IGNvbmZpZ3VyYXRpb24gKGhvdCB1cGRhdGVzIG9uIHNhbWUgc2VydmVyKS5cbi8vIEl0IG1ha2VzIHNvbWUgb3BpbmlvbmF0ZWQgY2hvaWNlcyBvbiB0b3AsIGxpa2UgYWRkaW5nIGEgc3ludGF4IGVycm9yIG92ZXJsYXlcbi8vIHRoYXQgbG9va3Mgc2ltaWxhciB0byBvdXIgY29uc29sZSBvdXRwdXQuIFRoZSBlcnJvciBvdmVybGF5IGlzIGluc3BpcmVkIGJ5OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlXG5sZXQgaGFkUnVudGltZUVycm9yID0gZmFsc2U7XG5sZXQgY3VzdG9tSG1yRXZlbnRIYW5kbGVyO1xuZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAoMCwgX2NsaWVudCkucmVnaXN0ZXIoKTtcbiAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCk9PntcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignYWN0aW9uJykgPT09IC0xKSByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9jZXNzTWVzc2FnZShldmVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgSE1SIG1lc3NhZ2U6ICcgKyBldmVudC5kYXRhICsgJ1xcbicgKyBleCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmVUb0htckV2ZW50IChoYW5kbGVyKSB7XG4gICAgICAgICAgICBjdXN0b21IbXJFdmVudEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB9LFxuICAgICAgICBvblVucmVjb3ZlcmFibGVFcnJvciAoKSB7XG4gICAgICAgICAgICBoYWRSdW50aW1lRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIFJlbWVtYmVyIHNvbWUgc3RhdGUgcmVsYXRlZCB0byBob3QgbW9kdWxlIHJlcGxhY2VtZW50LlxudmFyIGlzRmlyc3RDb21waWxhdGlvbiA9IHRydWU7XG52YXIgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IG51bGw7XG52YXIgaGFzQ29tcGlsZUVycm9ycyA9IGZhbHNlO1xuZnVuY3Rpb24gY2xlYXJPdXRkYXRlZEVycm9ycygpIHtcbiAgICAvLyBDbGVhbiB1cCBvdXRkYXRlZCBjb21waWxlIGVycm9ycywgaWYgYW55LlxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuY2xlYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGhhc0NvbXBpbGVFcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFN1Y2Nlc3NmdWwgY29tcGlsYXRpb24uXG5mdW5jdGlvbiBoYW5kbGVTdWNjZXNzKCkge1xuICAgIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKTtcbiAgICBjb25zdCBpc0hvdFVwZGF0ZSA9ICFpc0ZpcnN0Q29tcGlsYXRpb24gfHwgX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lICE9PSAnL19lcnJvcicgJiYgaXNVcGRhdGVBdmFpbGFibGUoKTtcbiAgICBpc0ZpcnN0Q29tcGlsYXRpb24gPSBmYWxzZTtcbiAgICBoYXNDb21waWxlRXJyb3JzID0gZmFsc2U7XG4gICAgLy8gQXR0ZW1wdCB0byBhcHBseSBob3QgdXBkYXRlcyBvciByZWxvYWQuXG4gICAgaWYgKGlzSG90VXBkYXRlKSB7XG4gICAgICAgIHRyeUFwcGx5VXBkYXRlcyhmdW5jdGlvbiBvblN1Y2Nlc3NmdWxIb3RVcGRhdGUoaGFzVXBkYXRlcykge1xuICAgICAgICAgICAgLy8gT25seSBkaXNtaXNzIGl0IHdoZW4gd2UncmUgc3VyZSBpdCdzIGEgaG90IHVwZGF0ZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCB3b3VsZCBmbGlja2VyIHJpZ2h0IGJlZm9yZSB0aGUgcmVsb2FkLlxuICAgICAgICAgICAgb25GYXN0UmVmcmVzaChoYXNVcGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8gQ29tcGlsYXRpb24gd2l0aCB3YXJuaW5ncyAoZS5nLiBFU0xpbnQpLlxuZnVuY3Rpb24gaGFuZGxlV2FybmluZ3Mod2FybmluZ3MpIHtcbiAgICBjbGVhck91dGRhdGVkRXJyb3JzKCk7XG4gICAgY29uc3QgaXNIb3RVcGRhdGUgPSAhaXNGaXJzdENvbXBpbGF0aW9uO1xuICAgIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlO1xuICAgIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBwcmludFdhcm5pbmdzKCkge1xuICAgICAgICAvLyBQcmludCB3YXJuaW5ncyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gKDAsIF9mb3JtYXRXZWJwYWNrTWVzc2FnZXMpLmRlZmF1bHQoe1xuICAgICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgICAgICAgICAgZXJyb3JzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLndhcm5pbmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZXJlIHdlcmUgbW9yZSB3YXJuaW5ncyBpbiBvdGhlciBmaWxlcy5cXG4nICsgJ1lvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIF9zdHJpcEFuc2kpLmRlZmF1bHQoZm9ybWF0dGVkLndhcm5pbmdzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRXYXJuaW5ncygpO1xuICAgIC8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuICAgIGlmIChpc0hvdFVwZGF0ZSkge1xuICAgICAgICB0cnlBcHBseVVwZGF0ZXMoZnVuY3Rpb24gb25TdWNjZXNzZnVsSG90VXBkYXRlKGhhc1VwZGF0ZXMpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZGlzbWlzcyBpdCB3aGVuIHdlJ3JlIHN1cmUgaXQncyBhIGhvdCB1cGRhdGUuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQgd291bGQgZmxpY2tlciByaWdodCBiZWZvcmUgdGhlIHJlbG9hZC5cbiAgICAgICAgICAgIG9uRmFzdFJlZnJlc2goaGFzVXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuZnVuY3Rpb24gaGFuZGxlRXJyb3JzKGVycm9ycykge1xuICAgIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKTtcbiAgICBpc0ZpcnN0Q29tcGlsYXRpb24gPSBmYWxzZTtcbiAgICBoYXNDb21waWxlRXJyb3JzID0gdHJ1ZTtcbiAgICAvLyBcIk1hc3NhZ2VcIiB3ZWJwYWNrIG1lc3NhZ2VzLlxuICAgIHZhciBmb3JtYXR0ZWQgPSAoMCwgX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcykuZGVmYXVsdCh7XG4gICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICB3YXJuaW5nczogW11cbiAgICB9KTtcbiAgICAvLyBPbmx5IHNob3cgdGhlIGZpcnN0IGVycm9yLlxuICAgICgwLCBfY2xpZW50KS5vbkJ1aWxkRXJyb3IoZm9ybWF0dGVkLmVycm9yc1swXSk7XG4gICAgLy8gQWxzbyBsb2cgdGhlbSB0byB0aGUgY29uc29sZS5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKDAsIF9zdHJpcEFuc2kpLmRlZmF1bHQoZm9ybWF0dGVkLmVycm9yc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBub3cuXG4gICAgLy8gV2Ugd2lsbCByZWxvYWQgb24gbmV4dCBzdWNjZXNzIGluc3RlYWQuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKGZvcm1hdHRlZC5lcnJvcnNbMF0pO1xuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzdGFydExhdGVuY3kgPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBvbkZhc3RSZWZyZXNoKGhhc1VwZGF0ZXMpIHtcbiAgICAoMCwgX2NsaWVudCkub25CdWlsZE9rKCk7XG4gICAgaWYgKGhhc1VwZGF0ZXMpIHtcbiAgICAgICAgKDAsIF9jbGllbnQpLm9uUmVmcmVzaCgpO1xuICAgIH1cbiAgICBpZiAoc3RhcnRMYXRlbmN5KSB7XG4gICAgICAgIGNvbnN0IGxhdGVuY3kgPSBEYXRlLm5vdygpIC0gc3RhcnRMYXRlbmN5O1xuICAgICAgICBjb25zb2xlLmxvZyhgW0Zhc3QgUmVmcmVzaF0gZG9uZSBpbiAke2xhdGVuY3l9bXNgKTtcbiAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9MQVRFTkNZX0NCKSB7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfTEFURU5DWV9DQihsYXRlbmN5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoZXJlIGlzIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgY29kZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBoYW5kbGVBdmFpbGFibGVIYXNoKGhhc2gpIHtcbiAgICAvLyBVcGRhdGUgbGFzdCBrbm93biBjb21waWxhdGlvbiBoYXNoLlxuICAgIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggPSBoYXNoO1xufVxuLy8gSGFuZGxlIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKGUpIHtcbiAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGUuZGF0YSk7XG4gICAgc3dpdGNoKG9iai5hY3Rpb24pe1xuICAgICAgICBjYXNlICdidWlsZGluZyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnRMYXRlbmN5ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0Zhc3QgUmVmcmVzaF0gcmVidWlsZGluZycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICdidWlsdCc6XG4gICAgICAgIGNhc2UgJ3N5bmMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVBdmFpbGFibGVIYXNoKG9iai5oYXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgLCB3YXJuaW5ncyAgfSA9IG9iajtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNFcnJvcnMgPSBCb29sZWFuKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcnMoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzV2FybmluZ3MgPSBCb29sZWFuKHdhcm5pbmdzICYmIHdhcm5pbmdzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1dhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVXYXJuaW5ncyh3YXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdWNjZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUhtckV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21IbXJFdmVudEhhbmRsZXIob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbi8vIElzIHRoZXJlIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGlzIGNvZGUgYXZhaWxhYmxlP1xuZnVuY3Rpb24gaXNVcGRhdGVBdmFpbGFibGUoKSB7XG4gICAgLyogZ2xvYmFscyBfX3dlYnBhY2tfaGFzaF9fICovIC8vIF9fd2VicGFja19oYXNoX18gaXMgdGhlIGhhc2ggb2YgdGhlIGN1cnJlbnQgY29tcGlsYXRpb24uXG4gICAgLy8gSXQncyBhIGdsb2JhbCB2YXJpYWJsZSBpbmplY3RlZCBieSBXZWJwYWNrLlxuICAgIHJldHVybiBtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoICE9PSBfX3dlYnBhY2tfaGFzaF9fO1xufVxuLy8gV2VicGFjayBkaXNhbGxvd3MgdXBkYXRlcyBpbiBvdGhlciBzdGF0ZXMuXG5mdW5jdGlvbiBjYW5BcHBseVVwZGF0ZXMoKSB7XG4gICAgcmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09ICdpZGxlJztcbn1cbmZ1bmN0aW9uIGFmdGVyQXBwbHlVcGRhdGVzKGZuKSB7XG4gICAgaWYgKGNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgICAgIGZuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlcihzdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdpZGxlJykge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG59XG4vLyBBdHRlbXB0IHRvIHVwZGF0ZSBjb2RlIG9uIHRoZSBmbHksIGZhbGwgYmFjayB0byBhIGhhcmQgcmVsb2FkLlxuZnVuY3Rpb24gdHJ5QXBwbHlVcGRhdGVzKG9uSG90VXBkYXRlU3VjY2Vzcykge1xuICAgIGlmICghbW9kdWxlLmhvdCkge1xuICAgICAgICAvLyBIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbiBpcyBub3QgaW4gV2VicGFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICBjb25zb2xlLmVycm9yKCdIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbiBpcyBub3QgaW4gV2VicGFjayBjb25maWd1cmF0aW9uLicpO1xuICAgICAgICAvLyB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc1VwZGF0ZUF2YWlsYWJsZSgpIHx8ICFjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgICAgICAoMCwgX2NsaWVudCkub25CdWlsZE9rKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgaWYgKGVyciB8fCBoYWRSdW50aW1lRXJyb3IgfHwgIXVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkXFxuXFxuJyArIFwiRmFzdCBSZWZyZXNoIHdpbGwgcGVyZm9ybSBhIGZ1bGwgcmVsb2FkIHdoZW4geW91IGVkaXQgYSBmaWxlIHRoYXQncyBpbXBvcnRlZCBieSBtb2R1bGVzIG91dHNpZGUgb2YgdGhlIFJlYWN0IHJlbmRlcmluZyB0cmVlLlxcblwiICsgJ1lvdSBtaWdodCBoYXZlIGEgZmlsZSB3aGljaCBleHBvcnRzIGEgUmVhY3QgY29tcG9uZW50IGJ1dCBhbHNvIGV4cG9ydHMgYSB2YWx1ZSB0aGF0IGlzIGltcG9ydGVkIGJ5IGEgbm9uLVJlYWN0IGNvbXBvbmVudCBmaWxlLlxcbicgKyAnQ29uc2lkZXIgbWlncmF0aW5nIHRoZSBub24tUmVhY3QgY29tcG9uZW50IGV4cG9ydCB0byBhIHNlcGFyYXRlIGZpbGUgYW5kIGltcG9ydGluZyBpdCBpbnRvIGJvdGggZmlsZXMuXFxuXFxuJyArICdJdCBpcyBhbHNvIHBvc3NpYmxlIHRoZSBwYXJlbnQgY29tcG9uZW50IG9mIHRoZSBjb21wb25lbnQgeW91IGVkaXRlZCBpcyBhIGNsYXNzIGNvbXBvbmVudCwgd2hpY2ggZGlzYWJsZXMgRmFzdCBSZWZyZXNoLlxcbicgKyAnRmFzdCBSZWZyZXNoIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBwYXJlbnQgZnVuY3Rpb24gY29tcG9uZW50IGluIHlvdXIgUmVhY3QgdHJlZS4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFkUnVudGltZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBoYWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1VwZGF0ZXMgPSBCb29sZWFuKHVwZGF0ZWRNb2R1bGVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25Ib3RVcGRhdGVTdWNjZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBNYXliZSB3ZSB3YW50IHRvIGRvIHNvbWV0aGluZy5cbiAgICAgICAgICAgIG9uSG90VXBkYXRlU3VjY2VzcyhoYXNVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVcGRhdGVBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgLy8gV2hpbGUgd2Ugd2VyZSB1cGRhdGluZywgdGhlcmUgd2FzIGEgbmV3IHVwZGF0ZSEgRG8gaXQgYWdhaW4uXG4gICAgICAgICAgICB0cnlBcHBseVVwZGF0ZXMoaGFzVXBkYXRlcyA/IF9jbGllbnQub25CdWlsZE9rIDogb25Ib3RVcGRhdGVTdWNjZXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICgwLCBfY2xpZW50KS5vbkJ1aWxkT2soKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJBcHBseVVwZGF0ZXMoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvaG90LW1vZHVsZS1yZXBsYWNlbWVudC8jY2hlY2tcbiAgICBtb2R1bGUuaG90LmNoZWNrKC8qIGF1dG9BcHBseSAqLyB0cnVlKS50aGVuKCh1cGRhdGVkTW9kdWxlcyk9PntcbiAgICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKG51bGwsIHVwZGF0ZWRNb2R1bGVzKTtcbiAgICB9LCAoZXJyKT0+e1xuICAgICAgICBoYW5kbGVBcHBseVVwZGF0ZXMoZXJyLCBudWxsKTtcbiAgICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG90LWRldi1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY29ubmVjdCIsIl9jbGllbnQiLCJyZXF1aXJlIiwiX3N0cmlwQW5zaSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfd2Vic29ja2V0IiwiX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcyIsIl9yb3V0ZXIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiaGFkUnVudGltZUVycm9yIiwiY3VzdG9tSG1yRXZlbnRIYW5kbGVyIiwicmVnaXN0ZXIiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJldmVudCIsImRhdGEiLCJpbmRleE9mIiwicHJvY2Vzc01lc3NhZ2UiLCJleCIsImNvbnNvbGUiLCJ3YXJuIiwic3Vic2NyaWJlVG9IbXJFdmVudCIsImhhbmRsZXIiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImlzRmlyc3RDb21waWxhdGlvbiIsIm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2giLCJoYXNDb21waWxlRXJyb3JzIiwiY2xlYXJPdXRkYXRlZEVycm9ycyIsImNsZWFyIiwiaGFuZGxlU3VjY2VzcyIsImlzSG90VXBkYXRlIiwicGF0aG5hbWUiLCJpc1VwZGF0ZUF2YWlsYWJsZSIsInRyeUFwcGx5VXBkYXRlcyIsIm9uU3VjY2Vzc2Z1bEhvdFVwZGF0ZSIsImhhc1VwZGF0ZXMiLCJvbkZhc3RSZWZyZXNoIiwiaGFuZGxlV2FybmluZ3MiLCJ3YXJuaW5ncyIsInByaW50V2FybmluZ3MiLCJmb3JtYXR0ZWQiLCJlcnJvcnMiLCJpIiwibGVuZ3RoIiwiaGFuZGxlRXJyb3JzIiwib25CdWlsZEVycm9yIiwiZXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1RFU1RfTU9ERSIsInNlbGYiLCJfX05FWFRfSE1SX0NCIiwic3RhcnRMYXRlbmN5IiwidW5kZWZpbmVkIiwib25CdWlsZE9rIiwib25SZWZyZXNoIiwibGF0ZW5jeSIsIkRhdGUiLCJub3ciLCJsb2ciLCJfX05FWFRfSE1SX0xBVEVOQ1lfQ0IiLCJoYW5kbGVBdmFpbGFibGVIYXNoIiwiaGFzaCIsImUiLCJKU09OIiwicGFyc2UiLCJhY3Rpb24iLCJoYXNFcnJvcnMiLCJCb29sZWFuIiwiaGFzV2FybmluZ3MiLCJfX3dlYnBhY2tfaGFzaF9fIiwiY2FuQXBwbHlVcGRhdGVzIiwibW9kdWxlIiwiaG90Iiwic3RhdHVzIiwiYWZ0ZXJBcHBseVVwZGF0ZXMiLCJmbiIsInJlbW92ZVN0YXR1c0hhbmRsZXIiLCJhZGRTdGF0dXNIYW5kbGVyIiwib25Ib3RVcGRhdGVTdWNjZXNzIiwiaGFuZGxlQXBwbHlVcGRhdGVzIiwiZXJyIiwidXBkYXRlZE1vZHVsZXMiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInJlbG9hZCIsImNoZWNrIiwidGhlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/regenerator */ \"./node_modules/next/node_modules/@babel/runtime/regenerator/index.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _router = _interopRequireDefault(__webpack_require__(/*! next/router */ \"./node_modules/next/router.js\"));\n\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar _default = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n  return _regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          setInterval(function () {\n            (0, _websocket).sendMessage(JSON.stringify({\n              event: 'ping',\n              page: _router[\"default\"].pathname\n            }));\n          }, 2500);\n          (0, _websocket).addMessageListener(function (event) {\n            if (event.data.indexOf('{') === -1) return;\n\n            try {\n              var payload = JSON.parse(event.data); // don't attempt fetching the page if we're already showing\n              // the dev overlay as this can cause the error to be triggered\n              // repeatedly\n\n              if (payload.event === 'pong' && payload.invalid && !self.__NEXT_DATA__.err) {\n                // Payload can be invalid even if the page does exist.\n                // So, we check if it can be created.\n                fetch(location.href, {\n                  credentials: 'same-origin'\n                }).then(function (pageRes) {\n                  if (pageRes.status === 200) {\n                    // Page exists now, reload\n                    location.reload();\n                  } else {\n                    // Page doesn't exist\n                    if (self.__NEXT_DATA__.page === _router[\"default\"].pathname && _router[\"default\"].pathname !== '/_error') {\n                      // We are still on the page,\n                      // reload to show 404 error page\n                      location.reload();\n                    }\n                  }\n                });\n              }\n            } catch (err) {\n              console.error('on-demand-entries failed to parse response', err);\n            }\n          });\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n}));\n\nexports[\"default\"] = _default;\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7OztBQUNiQSw4Q0FBNkM7QUFDekNHLEVBQUFBLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxrQkFBQSxHQUFrQixLQUFLLENBQXZCOztBQUNBLElBQUlFLE9BQU8sR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsa0RBQUQsQ0FBUixDQUFwQzs7QUFDQSxJQUFJQyxVQUFVLEdBQUdELG1CQUFPLENBQUMsaUdBQUQsQ0FBeEI7O0FBQ0EsU0FBU0Usa0JBQVQsQ0FBNEJDLEdBQTVCLEVBQWlDQyxPQUFqQyxFQUEwQ0MsTUFBMUMsRUFBa0RDLEtBQWxELEVBQXlEQyxNQUF6RCxFQUFpRUMsR0FBakUsRUFBc0VDLEdBQXRFLEVBQTJFO0FBQ3ZFLE1BQUk7QUFDQSxRQUFJQyxJQUFJLEdBQUdQLEdBQUcsQ0FBQ0ssR0FBRCxDQUFILENBQVNDLEdBQVQsQ0FBWDtBQUNBLFFBQUlaLEtBQUssR0FBR2EsSUFBSSxDQUFDYixLQUFqQjtBQUNILEdBSEQsQ0FHRSxPQUFPYyxLQUFQLEVBQWM7QUFDWk4sSUFBQUEsTUFBTSxDQUFDTSxLQUFELENBQU47QUFDQTtBQUNIOztBQUNELE1BQUlELElBQUksQ0FBQ0UsSUFBVCxFQUFlO0FBQ1hSLElBQUFBLE9BQU8sQ0FBQ1AsS0FBRCxDQUFQO0FBQ0gsR0FGRCxNQUVPO0FBQ0hnQixJQUFBQSxPQUFPLENBQUNULE9BQVIsQ0FBZ0JQLEtBQWhCLEVBQXVCaUIsSUFBdkIsQ0FBNEJSLEtBQTVCLEVBQW1DQyxNQUFuQztBQUNIO0FBQ0o7O0FBQ0QsU0FBU1EsaUJBQVQsQ0FBMkJDLEVBQTNCLEVBQStCO0FBQzNCLFNBQU8sWUFBVztBQUNkLFFBQUlDLElBQUksR0FBRyxJQUFYO0FBQUEsUUFBaUJDLElBQUksR0FBR0MsU0FBeEI7QUFDQSxXQUFPLElBQUlOLE9BQUosQ0FB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NkIsUUFBbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcz84NDVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yb3V0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKSk7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbnZhciBfZGVmYXVsdCA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcbiAgICBzZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgICAoMCwgX3dlYnNvY2tldCkuc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZXZlbnQ6ICdwaW5nJyxcbiAgICAgICAgICAgIHBhZ2U6IF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZVxuICAgICAgICB9KSk7XG4gICAgfSwgMjUwMCk7XG4gICAgKDAsIF93ZWJzb2NrZXQpLmFkZE1lc3NhZ2VMaXN0ZW5lcigoZXZlbnQpPT57XG4gICAgICAgIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ3snKSA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCBmZXRjaGluZyB0aGUgcGFnZSBpZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmdcbiAgICAgICAgICAgIC8vIHRoZSBkZXYgb3ZlcmxheSBhcyB0aGlzIGNhbiBjYXVzZSB0aGUgZXJyb3IgdG8gYmUgdHJpZ2dlcmVkXG4gICAgICAgICAgICAvLyByZXBlYXRlZGx5XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5ldmVudCA9PT0gJ3BvbmcnICYmIHBheWxvYWQuaW52YWxpZCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmVycikge1xuICAgICAgICAgICAgICAgIC8vIFBheWxvYWQgY2FuIGJlIGludmFsaWQgZXZlbiBpZiB0aGUgcGFnZSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBjaGVjayBpZiBpdCBjYW4gYmUgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICBmZXRjaChsb2NhdGlvbi5ocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXG4gICAgICAgICAgICAgICAgfSkudGhlbigocGFnZVJlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VSZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgZXhpc3RzIG5vdywgcmVsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0RBVEFfXy5wYWdlID09PSBfcm91dGVyLmRlZmF1bHQucGF0aG5hbWUgJiYgX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3RpbGwgb24gdGhlIHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsb2FkIHRvIHNob3cgNDA0IGVycm9yIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ29uLWRlbWFuZC1lbnRyaWVzIGZhaWxlZCB0byBwYXJzZSByZXNwb25zZScsIGVycik7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfcm91dGVyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfd2Vic29ja2V0IiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93Iiwia2V5IiwiYXJnIiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2RlZmF1bHQiLCJzZXRJbnRlcnZhbCIsInNlbmRNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImV2ZW50IiwicGFnZSIsInBhdGhuYW1lIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwiZGF0YSIsImluZGV4T2YiLCJwYXlsb2FkIiwicGFyc2UiLCJpbnZhbGlkIiwiX19ORVhUX0RBVEFfXyIsImZldGNoIiwibG9jYXRpb24iLCJocmVmIiwiY3JlZGVudGlhbHMiLCJwYWdlUmVzIiwic3RhdHVzIiwicmVsb2FkIiwiY29uc29sZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/on-demand-entries-client.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/regenerator */ \"./node_modules/next/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck */ \"./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/createClass */ \"./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar _inherits = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/inherits */ \"./node_modules/next/node_modules/@babel/runtime/helpers/inherits.js\");\n\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf */ \"./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ \"./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.initNext = initNext;\nexports.render = render;\nexports.renderError = renderError;\nexports.emitter = exports.router = exports.version = void 0;\n\n__webpack_require__(/*! @next/polyfill-module */ \"./node_modules/@next/polyfill-module/dist/polyfill-module.js\");\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\n\nvar _styledJsx = __webpack_require__(/*! styled-jsx */ \"./node_modules/styled-jsx/index.js\");\n\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\n\nvar _mitt = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\n\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\n\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\n\nvar _runtimeConfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\n\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\n\nvar _headManager = _interopRequireDefault(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\n\nvar _pageLoader = _interopRequireDefault(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\n\nvar _performanceRelayer = _interopRequireDefault(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\n\nvar _routeAnnouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\n\nvar _router1 = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\n\nvar _isError = _interopRequireDefault(__webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\n\nvar _vitals = __webpack_require__(/*! ./vitals */ \"./node_modules/next/dist/client/vitals.js\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nvar data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\nwindow.__NEXT_DATA__ = data;\nvar version = \"12.0.4\";\nexports.version = version;\n\nvar looseToArray = function looseToArray(input) {\n  return [].slice.call(input);\n};\n\nvar hydrateProps = data.props,\n    hydrateErr = data.err,\n    page = data.page,\n    query = data.query,\n    buildId = data.buildId,\n    assetPrefix = data.assetPrefix,\n    runtimeConfig = data.runtimeConfig,\n    dynamicIds = data.dynamicIds,\n    isFallback = data.isFallback,\n    locale = data.locale,\n    locales = data.locales,\n    domainLocales = data.domainLocales,\n    isPreview = data.isPreview,\n    rsc = data.rsc;\nvar defaultLocale = data.defaultLocale;\nvar prefix = assetPrefix || ''; // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n// So, this is how we do it in the client side at runtime\n\n__webpack_require__.p = \"\".concat(prefix, \"/_next/\") //eslint-disable-line\n; // Initialize next/config with the environment configuration\n\n(0, _runtimeConfig).setConfig({\n  serverRuntimeConfig: {},\n  publicRuntimeConfig: runtimeConfig || {}\n});\nvar asPath = (0, _utils).getURL(); // make sure not to attempt stripping basePath for 404s\n\nif ((0, _router).hasBasePath(asPath)) {\n  asPath = (0, _router).delBasePath(asPath);\n}\n\nif (false) { var detectedDomain, localePathResult, parsedAs, _require4, formatUrl, _require3, parseRelativeUrl, _require2, detectDomainLocale, _require, normalizeLocalePath; }\n\nif (data.scriptLoader) {\n  var _require5 = __webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\"),\n      initScriptLoader = _require5.initScriptLoader;\n\n  initScriptLoader(data.scriptLoader);\n}\n\nvar pageLoader = new _pageLoader[\"default\"](buildId, prefix);\n\nvar register = function register(_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      r = _ref2[0],\n      f = _ref2[1];\n\n  return pageLoader.routeLoader.onEntrypoint(r, f);\n};\n\nif (window.__NEXT_P) {\n  // Defer page registration for another tick. This will increase the overall\n  // latency in hydrating the page, but reduce the total blocking time.\n  window.__NEXT_P.map(function (p) {\n    return setTimeout(function () {\n      return register(p);\n    }, 0);\n  });\n}\n\nwindow.__NEXT_P = [];\nwindow.__NEXT_P.push = register;\nvar headManager = (0, _headManager)[\"default\"]();\nvar appElement = document.getElementById('__next');\n\nvar _lastRenderReject;\n\nvar webpackHMR;\nvar router;\nexports.router = router;\nvar CachedApp, onPerfEntry;\n\nheadManager.getIsSsr = function () {\n  return router.isSsr;\n};\n\nvar Container = /*#__PURE__*/function (_react$default$Compon) {\n  _inherits(Container, _react$default$Compon);\n\n  var _super = _createSuper(Container);\n\n  function Container() {\n    _classCallCheck(this, Container);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Container, [{\n    key: \"componentDidCatch\",\n    value: function componentDidCatch(componentErr, info) {\n      this.props.fn(componentErr, info);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.scrollToHash(); // We need to replace the router state if:\n      // - the page was (auto) exported and has a query string or search (hash)\n      // - it was auto exported and is a dynamic route (to provide params)\n      // - if it is a client-side skeleton (fallback render)\n\n      if (router.isSsr && // We don't update for 404 requests as this can modify\n      // the asPath unexpectedly e.g. adding basePath when\n      // it wasn't originally present\n      page !== '/404' && page !== '/_error' && (isFallback || data.nextExport && ((0, _isDynamic).isDynamicRoute(router.pathname) || location.search || false) || hydrateProps && hydrateProps.__N_SSG && (location.search || false))) {\n        // update query on mount for exported pages\n        router.replace(router.pathname + '?' + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n          // @ts-ignore\n          // WARNING: `_h` is an internal option for handing Next.js\n          // client-side hydration. Your app should _never_ use this property.\n          // It may change at any time without notice.\n          _h: 1,\n          // Fallback pages must trigger the data fetch, so the transition is\n          // not shallow.\n          // Other pages (strictly updating query) happens shallowly, as data\n          // requirements would already be present.\n          shallow: !isFallback\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.scrollToHash();\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash() {\n      var _location = location,\n          hash = _location.hash;\n      hash = hash && hash.substring(1);\n      if (!hash) return;\n      var el = document.getElementById(hash);\n      if (!el) return; // If we call scrollIntoView() in here without a setTimeout\n      // it won't scroll properly.\n\n      setTimeout(function () {\n        return el.scrollIntoView();\n      }, 0);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (false) {} else {\n        var _require6 = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\"),\n            ReactDevOverlay = _require6.ReactDevOverlay;\n\n        return /*#__PURE__*/_react[\"default\"].createElement(ReactDevOverlay, null, this.props.children);\n      }\n    }\n  }]);\n\n  return Container;\n}(_react[\"default\"].Component);\n\nvar emitter = (0, _mitt)[\"default\"]();\nexports.emitter = emitter;\nvar CachedComponent;\n\nfunction _initNext() {\n  _initNext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var opts,\n        initialErr,\n        appEntrypoint,\n        app,\n        mod,\n        exportedReportWebVitals,\n        pageEntrypoint,\n        _require7,\n        isValidElementType,\n        _require8,\n        getNodeError,\n        renderCtx,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            opts = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n\n            // This makes sure this specific lines are removed in production\n            if (true) {\n              webpackHMR = opts.webpackHMR;\n            }\n\n            initialErr = hydrateErr;\n            _context.prev = 3;\n            _context.next = 6;\n            return pageLoader.routeLoader.whenEntrypoint('/_app');\n\n          case 6:\n            appEntrypoint = _context.sent;\n\n            if (!('error' in appEntrypoint)) {\n              _context.next = 9;\n              break;\n            }\n\n            throw appEntrypoint.error;\n\n          case 9:\n            app = appEntrypoint.component, mod = appEntrypoint.exports;\n            CachedApp = app;\n            exportedReportWebVitals = mod && mod.reportWebVitals;\n\n            onPerfEntry = function onPerfEntry(_ref3) {\n              var id = _ref3.id,\n                  name = _ref3.name,\n                  startTime = _ref3.startTime,\n                  value = _ref3.value,\n                  duration = _ref3.duration,\n                  entryType = _ref3.entryType,\n                  entries = _ref3.entries;\n              // Combines timestamp with random number for unique ID\n              var uniqueID = \"\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * (9000000000000 - 1)) + 1000000000000);\n              var perfStartEntry;\n\n              if (entries && entries.length) {\n                perfStartEntry = entries[0].startTime;\n              }\n\n              var webVitals = {\n                id: id || uniqueID,\n                name: name,\n                startTime: startTime || perfStartEntry,\n                value: value == null ? duration : value,\n                label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n              };\n              exportedReportWebVitals === null || exportedReportWebVitals === void 0 ? void 0 : exportedReportWebVitals(webVitals);\n              (0, _vitals).trackWebVitalMetric(webVitals);\n            };\n\n            if (!( true && hydrateErr)) {\n              _context.next = 17;\n              break;\n            }\n\n            _context.t0 = {\n              error: hydrateErr\n            };\n            _context.next = 20;\n            break;\n\n          case 17:\n            _context.next = 19;\n            return pageLoader.routeLoader.whenEntrypoint(page);\n\n          case 19:\n            _context.t0 = _context.sent;\n\n          case 20:\n            pageEntrypoint = _context.t0;\n\n            if (!('error' in pageEntrypoint)) {\n              _context.next = 23;\n              break;\n            }\n\n            throw pageEntrypoint.error;\n\n          case 23:\n            CachedComponent = pageEntrypoint.component;\n\n            if (false) {}\n\n            _require7 = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\"), isValidElementType = _require7.isValidElementType;\n\n            if (isValidElementType(CachedComponent)) {\n              _context.next = 28;\n              break;\n            }\n\n            throw new Error(\"The default export is not a React Component in page: \\\"\".concat(page, \"\\\"\"));\n\n          case 28:\n            _context.next = 33;\n            break;\n\n          case 30:\n            _context.prev = 30;\n            _context.t1 = _context[\"catch\"](3);\n            // This catches errors like throwing in the top level of a module\n            initialErr = (0, _isError)[\"default\"](_context.t1) ? _context.t1 : new Error(_context.t1 + '');\n\n          case 33:\n            if (true) {\n              _require8 = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\"), getNodeError = _require8.getNodeError; // Server-side runtime errors need to be re-thrown on the client-side so\n              // that the overlay is rendered.\n\n              if (initialErr) {\n                if (initialErr === hydrateErr) {\n                  setTimeout(function () {\n                    var error;\n\n                    try {\n                      // Generate a new error object. We `throw` it because some browsers\n                      // will set the `stack` when thrown, and we want to ensure ours is\n                      // not overridden when we re-throw it below.\n                      throw new Error(initialErr.message);\n                    } catch (e) {\n                      error = e;\n                    }\n\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack; // Errors from the middleware are reported as client-side errors\n                    // since the middleware is compiled using the client compiler\n\n                    if ('middleware' in hydrateErr) {\n                      throw error;\n                    }\n\n                    var node = getNodeError(error);\n                    throw node;\n                  });\n                } else {\n                  setTimeout(function () {\n                    throw initialErr;\n                  });\n                }\n              }\n            }\n\n            if (!window.__NEXT_PRELOADREADY) {\n              _context.next = 37;\n              break;\n            }\n\n            _context.next = 37;\n            return window.__NEXT_PRELOADREADY(dynamicIds);\n\n          case 37:\n            exports.router = router = (0, _router1).createRouter(page, query, asPath, {\n              initialProps: hydrateProps,\n              pageLoader: pageLoader,\n              App: CachedApp,\n              Component: CachedComponent,\n              wrapApp: wrapApp,\n              err: initialErr,\n              isFallback: Boolean(isFallback),\n              subscription: function subscription(info, App, scroll) {\n                return render(Object.assign({}, info, {\n                  App: App,\n                  scroll: scroll\n                }));\n              },\n              locale: locale,\n              locales: locales,\n              defaultLocale: defaultLocale,\n              domainLocales: domainLocales,\n              isPreview: isPreview\n            });\n            renderCtx = {\n              App: CachedApp,\n              initial: true,\n              Component: CachedComponent,\n              props: hydrateProps,\n              err: initialErr\n            };\n\n            if (true) {\n              _context.next = 44;\n              break;\n            }\n\n            render(renderCtx);\n            return _context.abrupt(\"return\", emitter);\n\n          case 44:\n            return _context.abrupt(\"return\", {\n              emitter: emitter,\n              renderCtx: renderCtx\n            });\n\n          case 45:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 30]]);\n  }));\n  return _initNext.apply(this, arguments);\n}\n\nfunction initNext() {\n  return _initNext.apply(this, arguments);\n}\n\nfunction _render() {\n  _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(renderingProps) {\n    var renderErr;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!renderingProps.err) {\n              _context2.next = 4;\n              break;\n            }\n\n            _context2.next = 3;\n            return renderError(renderingProps);\n\n          case 3:\n            return _context2.abrupt(\"return\");\n\n          case 4:\n            _context2.prev = 4;\n            _context2.next = 7;\n            return doRender(renderingProps);\n\n          case 7:\n            _context2.next = 17;\n            break;\n\n          case 9:\n            _context2.prev = 9;\n            _context2.t0 = _context2[\"catch\"](4);\n            renderErr = _context2.t0 instanceof Error ? _context2.t0 : new Error(_context2.t0 + ''); // bubble up cancelation errors\n\n            if (!renderErr.cancelled) {\n              _context2.next = 14;\n              break;\n            }\n\n            throw renderErr;\n\n          case 14:\n            if (true) {\n              // Ensure this error is displayed in the overlay in development\n              setTimeout(function () {\n                throw renderErr;\n              });\n            }\n\n            _context2.next = 17;\n            return renderError(_objectSpread({}, renderingProps, {\n              err: renderErr\n            }));\n\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[4, 9]]);\n  }));\n  return _render.apply(this, arguments);\n}\n\nfunction render(renderingProps) {\n  return _render.apply(this, arguments);\n}\n\nfunction renderError(renderErrorProps) {\n  var App = renderErrorProps.App,\n      err = renderErrorProps.err; // In development runtime errors are caught by our overlay\n  // In production we catch runtime errors using componentDidCatch which will trigger renderError\n\n  if (true) {\n    // A Next.js rendering runtime error is always unrecoverable\n    // FIXME: let's make this recoverable (error in GIP client-transition)\n    webpackHMR.onUnrecoverableError(); // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n    // render itself.\n\n    return doRender({\n      App: function App() {\n        return null;\n      },\n      props: {},\n      Component: function Component() {\n        return null;\n      },\n      styleSheets: []\n    });\n  } // Make sure we log the error to the console, otherwise users can't track down issues.\n\n\n  console.error(err);\n  console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n  return pageLoader.loadPage('/_error').then(function (_ref4) {\n    var ErrorComponent = _ref4.page,\n        styleSheets = _ref4.styleSheets;\n    return (lastAppProps === null || lastAppProps === void 0 ? void 0 : lastAppProps.Component) === ErrorComponent ? __webpack_require__.e(/*! import() */ \"node_modules_next_dist_pages__error_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\", 23)).then(function (m) {\n      return {\n        ErrorComponent: m[\"default\"],\n        styleSheets: []\n      };\n    }) : {\n      ErrorComponent: ErrorComponent,\n      styleSheets: styleSheets\n    };\n  }).then(function (_ref5) {\n    var ErrorComponent = _ref5.ErrorComponent,\n        styleSheets = _ref5.styleSheets;\n    // In production we do a normal render with the `ErrorComponent` as component.\n    // If we've gotten here upon initial render, we can use the props from the server.\n    // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n    var AppTree = wrapApp(App);\n    var appCtx = {\n      Component: ErrorComponent,\n      AppTree: AppTree,\n      router: router,\n      ctx: {\n        err: err,\n        pathname: page,\n        query: query,\n        asPath: asPath,\n        AppTree: AppTree\n      }\n    };\n    return Promise.resolve(renderErrorProps.props ? renderErrorProps.props : (0, _utils).loadGetInitialProps(App, appCtx)).then(function (initProps) {\n      return doRender(_objectSpread({}, renderErrorProps, {\n        err: err,\n        Component: ErrorComponent,\n        styleSheets: styleSheets,\n        props: initProps\n      }));\n    });\n  });\n}\n\nvar reactRoot = null; // On initial render a hydrate should always happen\n\nvar shouldHydrate = true;\n\nfunction renderReactElement(domEl, fn) {\n  // mark start of hydrate/render\n  if (_utils.ST) {\n    performance.mark('beforeRender');\n  }\n\n  var reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n\n  if (false) {} else {\n    // The check for `.hydrate` is there to support React alternatives like preact\n    if (shouldHydrate) {\n      _reactDom[\"default\"].hydrate(reactEl, domEl);\n\n      shouldHydrate = false;\n    } else {\n      _reactDom[\"default\"].render(reactEl, domEl);\n    }\n  }\n}\n\nfunction markHydrateComplete() {\n  if (!_utils.ST) return;\n  performance.mark('afterHydrate') // mark end of hydration\n  ;\n  performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');\n  performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');\n\n  if (onPerfEntry) {\n    performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);\n  }\n\n  clearMarks();\n}\n\nfunction markRenderComplete() {\n  if (!_utils.ST) return;\n  performance.mark('afterRender') // mark end of render\n  ;\n  var navStartEntries = performance.getEntriesByName('routeChange', 'mark');\n  if (!navStartEntries.length) return;\n  performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');\n  performance.measure('Next.js-render', 'beforeRender', 'afterRender');\n\n  if (onPerfEntry) {\n    performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);\n    performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);\n  }\n\n  clearMarks();\n  ['Next.js-route-change-to-render', 'Next.js-render'].forEach(function (measure) {\n    return performance.clearMeasures(measure);\n  });\n}\n\nfunction clearMarks() {\n  ['beforeRender', 'afterHydrate', 'afterRender', 'routeChange'].forEach(function (mark) {\n    return performance.clearMarks(mark);\n  });\n}\n\nfunction AppContainer(_ref6) {\n  var children = _ref6.children;\n  return /*#__PURE__*/_react[\"default\"].createElement(Container, {\n    fn: function fn(error) {\n      return renderError({\n        App: CachedApp,\n        err: error\n      })[\"catch\"](function (err) {\n        return console.error('Error rendering page: ', err);\n      });\n    }\n  }, /*#__PURE__*/_react[\"default\"].createElement(_routerContext.RouterContext.Provider, {\n    value: (0, _router1).makePublicRouterInstance(router)\n  }, /*#__PURE__*/_react[\"default\"].createElement(_headManagerContext.HeadManagerContext.Provider, {\n    value: headManager\n  }, /*#__PURE__*/_react[\"default\"].createElement(_styledJsx.StyleRegistry, null, children))));\n}\n\n_c = AppContainer;\n\nvar wrapApp = function wrapApp(App) {\n  return function (wrappedAppProps) {\n    var appProps = _objectSpread({}, wrappedAppProps, {\n      Component: CachedComponent,\n      err: hydrateErr,\n      router: router\n    });\n\n    return /*#__PURE__*/_react[\"default\"].createElement(AppContainer, null, /*#__PURE__*/_react[\"default\"].createElement(App, Object.assign({}, appProps)));\n  };\n};\n\nvar RSCComponent;\n\nif (false) { var RSCWrapper, rscCache, createResponseCache, _s; }\n\nvar lastAppProps;\n\nfunction doRender(input) {\n  var App = input.App,\n      Component = input.Component,\n      props = input.props,\n      err = input.err,\n      __N_RSC = input.__N_RSC;\n  var styleSheets = 'initial' in input ? undefined : input.styleSheets;\n  Component = Component || lastAppProps.Component;\n  props = props || lastAppProps.props;\n  var isRSC =  false ? 0 : !!__N_RSC;\n\n  var appProps = _objectSpread({}, props, {\n    Component: isRSC ? RSCComponent : Component,\n    err: err,\n    router: router\n  }); // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n\n\n  lastAppProps = appProps;\n  var canceled = false;\n  var resolvePromise;\n  var renderPromise = new Promise(function (resolve, reject) {\n    if (_lastRenderReject) {\n      _lastRenderReject();\n    }\n\n    resolvePromise = function resolvePromise() {\n      _lastRenderReject = null;\n      resolve();\n    };\n\n    _lastRenderReject = function lastRenderReject() {\n      canceled = true;\n      _lastRenderReject = null;\n      var error = new Error('Cancel rendering route');\n      error.cancelled = true;\n      reject(error);\n    };\n  }); // This function has a return type to ensure it doesn't start returning a\n  // Promise. It should remain synchronous.\n\n  function onStart() {\n    if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n    // unless we're in production:\n    true) {\n      return false;\n    }\n\n    var currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n    var currentHrefs = new Set(currentStyleTags.map(function (tag) {\n      return tag.getAttribute('data-n-href');\n    }));\n    var noscript = document.querySelector('noscript[data-n-css]');\n    var nonce = noscript === null || noscript === void 0 ? void 0 : noscript.getAttribute('data-n-css');\n    styleSheets.forEach(function (_ref8) {\n      var href = _ref8.href,\n          text = _ref8.text;\n\n      if (!currentHrefs.has(href)) {\n        var styleTag = document.createElement('style');\n        styleTag.setAttribute('data-n-href', href);\n        styleTag.setAttribute('media', 'x');\n\n        if (nonce) {\n          styleTag.setAttribute('nonce', nonce);\n        }\n\n        document.head.appendChild(styleTag);\n        styleTag.appendChild(document.createTextNode(text));\n      }\n    });\n    return true;\n  }\n\n  function onHeadCommit() {\n    if ( // We use `style-loader` in development, so we don't need to do anything\n    // unless we're in production:\n    false) { var referenceNode, idx, currentHrefs, currentStyleTags, desiredHrefs; }\n\n    if (input.scroll) {\n      window.scrollTo(input.scroll.x, input.scroll.y);\n    }\n  }\n\n  function onRootCommit() {\n    resolvePromise();\n  }\n\n  onStart();\n\n  var elem = /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, /*#__PURE__*/_react[\"default\"].createElement(Head, {\n    callback: onHeadCommit\n  }), /*#__PURE__*/_react[\"default\"].createElement(AppContainer, null, /*#__PURE__*/_react[\"default\"].createElement(App, Object.assign({}, appProps)), /*#__PURE__*/_react[\"default\"].createElement(_portal.Portal, {\n    type: \"next-route-announcer\"\n  }, /*#__PURE__*/_react[\"default\"].createElement(_routeAnnouncer.RouteAnnouncer, null)))); // We catch runtime errors using componentDidCatch which will trigger renderError\n\n\n  renderReactElement(appElement, function (callback) {\n    return /*#__PURE__*/_react[\"default\"].createElement(Root, {\n      callbacks: [callback, onRootCommit]\n    },  true ? /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].StrictMode, null, elem) : 0);\n  });\n  return renderPromise;\n}\n\nfunction Root(_ref10) {\n  _s2();\n\n  var callbacks = _ref10.callbacks,\n      children = _ref10.children;\n\n  // We use `useLayoutEffect` to guarantee the callbacks are executed\n  // as soon as React flushes the update\n  _react[\"default\"].useLayoutEffect(function () {\n    return callbacks.forEach(function (callback) {\n      return callback();\n    });\n  }, [callbacks]);\n\n  if (undefined) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    _react[\"default\"].useEffect(function () {\n      window.__NEXT_HYDRATED = true;\n\n      if (window.__NEXT_HYDRATED_CB) {\n        window.__NEXT_HYDRATED_CB();\n      }\n    }, []);\n  } // We should ask to measure the Web Vitals after rendering completes so we\n  // don't cause any hydration delay:\n\n\n  _react[\"default\"].useEffect(function () {\n    (0, _performanceRelayer)[\"default\"](onPerfEntry);\n  }, []);\n\n  return children;\n} // Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\n\n\n_s2(Root, \"KDoBXdlwSU+O+uFsByO25XxhKDU=\");\n\n_c2 = Root;\n\nfunction Head(_ref11) {\n  _s3();\n\n  var callback = _ref11.callback;\n\n  // We use `useLayoutEffect` to guarantee the callback is executed\n  // as soon as React flushes the update.\n  _react[\"default\"].useLayoutEffect(function () {\n    return callback();\n  }, [callback]);\n\n  return null;\n}\n\n_s3(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n\n_c3 = Head;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c2, \"Root\");\n$RefreshReg$(_c3, \"Head\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztBQUN6Q0csRUFBQUEsS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELGdCQUFBLEdBQW1CRSxRQUFuQjtBQUNBRixjQUFBLEdBQWlCRyxNQUFqQjtBQUNBSCxtQkFBQSxHQUFzQkksV0FBdEI7QUFDQUosZUFBQSxHQUFrQkEsY0FBQSxHQUFpQkEsZUFBQSxHQUFrQixLQUFLLENBQTFEOztBQUNBUSxtQkFBTyxDQUFDLDJGQUFELENBQVA7O0FBQ0EsSUFBSUMsTUFBTSxHQUFHQyxzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFSLENBQW5DOztBQUNBLElBQUlHLFNBQVMsR0FBR0Qsc0JBQXNCLENBQUNGLG1CQUFPLENBQUMsb0RBQUQsQ0FBUixDQUF0Qzs7QUFDQSxJQUFJSSxVQUFVLEdBQUdKLG1CQUFPLENBQUMsc0RBQUQsQ0FBeEI7O0FBQ0EsSUFBSUssbUJBQW1CLEdBQUdMLG1CQUFPLENBQUMsdUdBQUQsQ0FBakM7O0FBQ0EsSUFBSU0sS0FBSyxHQUFHSixzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyx1RUFBRCxDQUFSLENBQWxDOztBQUNBLElBQUlPLGNBQWMsR0FBR1AsbUJBQU8sQ0FBQywyRkFBRCxDQUE1Qjs7QUFDQSxJQUFJUSxPQUFPLEdBQUdSLG1CQUFPLENBQUMseUZBQUQsQ0FBckI7O0FBQ0EsSUFBSVMsVUFBVSxHQUFHVCxtQkFBTyxDQUFDLDZHQUFELENBQXhCOztBQUNBLElBQUlVLFlBQVksR0FBR1YsbUJBQU8sQ0FBQywrR0FBRCxDQUExQjs7QUFDQSxJQUFJVyxjQUFjLEdBQUdYLG1CQUFPLENBQUMsMkZBQUQsQ0FBNUI7O0FBQ0EsSUFBSVksTUFBTSxHQUFHWixtQkFBTyxDQUFDLHlFQUFELENBQXBCOztBQUNBLElBQUlhLE9BQU8sR0FBR2IsbUJBQU8s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QTs7QUFBQSxNQUFiQyxRQUFhLFVBQWJBLFFBQWE7O0FBQ3pCO0FBQ0E7QUFDQWpVLEVBQUFBLE1BQU0sV0FBTixDQUFleVUsZUFBZixDQUErQjtBQUFBLFdBQUlSLFFBQVEsRUFBWjtBQUFBLEdBQS9CLEVBQ0UsQ0FDRUEsUUFERixDQURGOztBQUlBLFNBQU8sSUFBUDtBQUNIOztJQVJRRDs7TUFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW5kZXguanM/NDZjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaW5pdE5leHQgPSBpbml0TmV4dDtcbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZXhwb3J0cy5yZW5kZXJFcnJvciA9IHJlbmRlckVycm9yO1xuZXhwb3J0cy5lbWl0dGVyID0gZXhwb3J0cy5yb3V0ZXIgPSBleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5yZXF1aXJlKFwiQG5leHQvcG9seWZpbGwtbW9kdWxlXCIpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9zdHlsZWRKc3ggPSByZXF1aXJlKFwic3R5bGVkLWpzeFwiKTtcbnZhciBfaGVhZE1hbmFnZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHRcIik7XG52YXIgX21pdHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL21pdHRcIikpO1xudmFyIF9yb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXJcIik7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbnZhciBfcnVudGltZUNvbmZpZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3J1bnRpbWUtY29uZmlnXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xudmFyIF9wb3J0YWwgPSByZXF1aXJlKFwiLi9wb3J0YWxcIik7XG52YXIgX2hlYWRNYW5hZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXJcIikpO1xudmFyIF9wYWdlTG9hZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYWdlLWxvYWRlclwiKSk7XG52YXIgX3BlcmZvcm1hbmNlUmVsYXllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGVyZm9ybWFuY2UtcmVsYXllclwiKSk7XG52YXIgX3JvdXRlQW5ub3VuY2VyID0gcmVxdWlyZShcIi4vcm91dGUtYW5ub3VuY2VyXCIpO1xudmFyIF9yb3V0ZXIxID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xudmFyIF9pc0Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbGliL2lzLWVycm9yXCIpKTtcbnZhciBfdml0YWxzID0gcmVxdWlyZShcIi4vdml0YWxzXCIpO1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdPYmogPSB7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBkYXRhID0gSlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpLnRleHRDb250ZW50KTtcbndpbmRvdy5fX05FWFRfREFUQV9fID0gZGF0YTtcbmNvbnN0IHZlcnNpb24gPSBcIjEyLjAuNFwiO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmNvbnN0IGxvb3NlVG9BcnJheSA9IChpbnB1dCk9PltdLnNsaWNlLmNhbGwoaW5wdXQpXG47XG5jb25zdCB7IHByb3BzOiBoeWRyYXRlUHJvcHMgLCBlcnI6IGh5ZHJhdGVFcnIgLCBwYWdlICwgcXVlcnkgLCBidWlsZElkICwgYXNzZXRQcmVmaXggLCBydW50aW1lQ29uZmlnICwgZHluYW1pY0lkcyAsIGlzRmFsbGJhY2sgLCBsb2NhbGUgLCBsb2NhbGVzICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAsIHJzYyAsICB9ID0gZGF0YTtcbmxldCB7IGRlZmF1bHRMb2NhbGUgIH0gPSBkYXRhO1xuY29uc3QgcHJlZml4ID0gYXNzZXRQcmVmaXggfHwgJyc7XG4vLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4vLyBTbywgdGhpcyBpcyBob3cgd2UgZG8gaXQgaW4gdGhlIGNsaWVudCBzaWRlIGF0IHJ1bnRpbWVcbl9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gYCR7cHJlZml4fS9fbmV4dC9gIC8vZXNsaW50LWRpc2FibGUtbGluZVxuO1xuLy8gSW5pdGlhbGl6ZSBuZXh0L2NvbmZpZyB3aXRoIHRoZSBlbnZpcm9ubWVudCBjb25maWd1cmF0aW9uXG4oMCwgX3J1bnRpbWVDb25maWcpLnNldENvbmZpZyh7XG4gICAgc2VydmVyUnVudGltZUNvbmZpZzoge1xuICAgIH0sXG4gICAgcHVibGljUnVudGltZUNvbmZpZzogcnVudGltZUNvbmZpZyB8fCB7XG4gICAgfVxufSk7XG5sZXQgYXNQYXRoID0gKDAsIF91dGlscykuZ2V0VVJMKCk7XG4vLyBtYWtlIHN1cmUgbm90IHRvIGF0dGVtcHQgc3RyaXBwaW5nIGJhc2VQYXRoIGZvciA0MDRzXG5pZiAoKDAsIF9yb3V0ZXIpLmhhc0Jhc2VQYXRoKGFzUGF0aCkpIHtcbiAgICBhc1BhdGggPSAoMCwgX3JvdXRlcikuZGVsQmFzZVBhdGgoYXNQYXRoKTtcbn1cbmlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgY29uc3QgeyBub3JtYWxpemVMb2NhbGVQYXRoICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpO1xuICAgIGNvbnN0IHsgZGV0ZWN0RG9tYWluTG9jYWxlICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJyk7XG4gICAgY29uc3QgeyBwYXJzZVJlbGF0aXZlVXJsICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJyk7XG4gICAgY29uc3QgeyBmb3JtYXRVcmwgIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJyk7XG4gICAgaWYgKGxvY2FsZXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCBsb2NhbGVzKTtcbiAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgIGFzUGF0aCA9IGZvcm1hdFVybChwYXJzZWRBcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGRlZmF1bHQgbG9jYWxlIGlmIGl0IHdhc24ndCBkZXRlY3RlZCBpbiB0aGUgYXNQYXRoXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBwcmVyZW5kZXIgc3RhdGljIHBhZ2VzIHdpdGggYWxsIHBvc3NpYmxlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGxvY2FsZXNcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXR0ZW1wdCBkZXRlY3RpbmcgZGVmYXVsdCBsb2NhbGUgYmFzZWQgb24gaG9zdG5hbWVcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fRE9NQUlOUywgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgaWYgZGVmYXVsdExvY2FsZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXJcbiAgICAgICAgLy8gaHlkcmF0aW9uIHRvIHByZXZlbnQgbWlzbWF0Y2hlZCByZW5kZXJzXG4gICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgZGVmYXVsdExvY2FsZSA9IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoZGF0YS5zY3JpcHRMb2FkZXIpIHtcbiAgICBjb25zdCB7IGluaXRTY3JpcHRMb2FkZXIgIH0gPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuICAgIGluaXRTY3JpcHRMb2FkZXIoZGF0YS5zY3JpcHRMb2FkZXIpO1xufVxuY29uc3QgcGFnZUxvYWRlciA9IG5ldyBfcGFnZUxvYWRlci5kZWZhdWx0KGJ1aWxkSWQsIHByZWZpeCk7XG5jb25zdCByZWdpc3RlciA9IChbciwgZl0pPT5wYWdlTG9hZGVyLnJvdXRlTG9hZGVyLm9uRW50cnlwb2ludChyLCBmKVxuO1xuaWYgKHdpbmRvdy5fX05FWFRfUCkge1xuICAgIC8vIERlZmVyIHBhZ2UgcmVnaXN0cmF0aW9uIGZvciBhbm90aGVyIHRpY2suIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbFxuICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgIHdpbmRvdy5fX05FWFRfUC5tYXAoKHApPT5zZXRUaW1lb3V0KCgpPT5yZWdpc3RlcihwKVxuICAgICAgICAsIDApXG4gICAgKTtcbn1cbndpbmRvdy5fX05FWFRfUCA9IFtdO1xud2luZG93Ll9fTkVYVF9QLnB1c2ggPSByZWdpc3RlcjtcbmNvbnN0IGhlYWRNYW5hZ2VyID0gKDAsIF9oZWFkTWFuYWdlcikuZGVmYXVsdCgpO1xuY29uc3QgYXBwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQnKTtcbmxldCBsYXN0UmVuZGVyUmVqZWN0O1xubGV0IHdlYnBhY2tITVI7XG5sZXQgcm91dGVyO1xuZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXI7XG5sZXQgQ2FjaGVkQXBwLCBvblBlcmZFbnRyeTtcbmhlYWRNYW5hZ2VyLmdldElzU3NyID0gKCk9PntcbiAgICByZXR1cm4gcm91dGVyLmlzU3NyO1xufTtcbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyLCBpbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMuZm4oY29tcG9uZW50RXJyLCBpbmZvKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuICAgICAgICAvLyAtIHRoZSBwYWdlIHdhcyAoYXV0bykgZXhwb3J0ZWQgYW5kIGhhcyBhIHF1ZXJ5IHN0cmluZyBvciBzZWFyY2ggKGhhc2gpXG4gICAgICAgIC8vIC0gaXQgd2FzIGF1dG8gZXhwb3J0ZWQgYW5kIGlzIGEgZHluYW1pYyByb3V0ZSAodG8gcHJvdmlkZSBwYXJhbXMpXG4gICAgICAgIC8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuICAgICAgICBpZiAocm91dGVyLmlzU3NyICYmIC8vIFdlIGRvbid0IHVwZGF0ZSBmb3IgNDA0IHJlcXVlc3RzIGFzIHRoaXMgY2FuIG1vZGlmeVxuICAgICAgICAvLyB0aGUgYXNQYXRoIHVuZXhwZWN0ZWRseSBlLmcuIGFkZGluZyBiYXNlUGF0aCB3aGVuXG4gICAgICAgIC8vIGl0IHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnRcbiAgICAgICAgcGFnZSAhPT0gJy80MDQnICYmIHBhZ2UgIT09ICcvX2Vycm9yJyAmJiAoaXNGYWxsYmFjayB8fCBkYXRhLm5leHRFeHBvcnQgJiYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZXIucGF0aG5hbWUpIHx8IGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB8fCBoeWRyYXRlUHJvcHMgJiYgaHlkcmF0ZVByb3BzLl9fTl9TU0cgJiYgKGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSkpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbiAgICAgICAgICAgIHJvdXRlci5yZXBsYWNlKHJvdXRlci5wYXRobmFtZSArICc/JyArIFN0cmluZygoMCwgX3F1ZXJ5c3RyaW5nKS5hc3NpZ24oKDAsIF9xdWVyeXN0cmluZykudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhyb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgYXNQYXRoLCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICAgICAgX2g6IDEsXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgcGFnZXMgbXVzdCB0cmlnZ2VyIHRoZSBkYXRhIGZldGNoLCBzbyB0aGUgdHJhbnNpdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgICAgICAgIC8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlbWVudHMgd291bGQgYWxyZWFkeSBiZSBwcmVzZW50LlxuICAgICAgICAgICAgICAgIHNoYWxsb3c6ICFpc0ZhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaCgpIHtcbiAgICAgICAgbGV0IHsgaGFzaCAgfSA9IGxvY2F0aW9uO1xuICAgICAgICBoYXNoID0gaGFzaCAmJiBoYXNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKCFoYXNoKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCk7XG4gICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgY2FsbCBzY3JvbGxJbnRvVmlldygpIGluIGhlcmUgd2l0aG91dCBhIHNldFRpbWVvdXRcbiAgICAgICAgLy8gaXQgd29uJ3Qgc2Nyb2xsIHByb3Blcmx5LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT5lbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICwgMCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBSZWFjdERldk92ZXJsYXkgIH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4oLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0RGV2T3ZlcmxheSwgbnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZW1pdHRlciA9ICgwLCBfbWl0dCkuZGVmYXVsdCgpO1xuZXhwb3J0cy5lbWl0dGVyID0gZW1pdHRlcjtcbmxldCBDYWNoZWRDb21wb25lbnQ7XG5mdW5jdGlvbiBfaW5pdE5leHQoKSB7XG4gICAgX2luaXROZXh0ID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qKG9wdHMgPSB7XG4gICAgfSkge1xuICAgICAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhpcyBzcGVjaWZpYyBsaW5lcyBhcmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgd2VicGFja0hNUiA9IG9wdHMud2VicGFja0hNUjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdGlhbEVyciA9IGh5ZHJhdGVFcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhcHBFbnRyeXBvaW50ID0geWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludCgnL19hcHAnKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGFwcEVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCAsIGV4cG9ydHM6IG1vZCAgfSA9IGFwcEVudHJ5cG9pbnQ7XG4gICAgICAgICAgICBDYWNoZWRBcHAgPSBhcHA7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9IG1vZCAmJiBtb2QucmVwb3J0V2ViVml0YWxzO1xuICAgICAgICAgICAgb25QZXJmRW50cnkgPSAoeyBpZCAsIG5hbWUgLCBzdGFydFRpbWUgLCB2YWx1ZSAsIGR1cmF0aW9uICwgZW50cnlUeXBlICwgZW50cmllcyAgfSk9PntcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVJRCA9IGAke0RhdGUubm93KCl9LSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDkwMDAwMDAwMDAwMDAgLSAxKSkgKyAxMDAwMDAwMDAwMDAwfWA7XG4gICAgICAgICAgICAgICAgbGV0IHBlcmZTdGFydEVudHJ5O1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZTdGFydEVudHJ5ID0gZW50cmllc1swXS5zdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdlYlZpdGFscyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkIHx8IHVuaXF1ZUlELFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSB8fCBwZXJmU3RhcnRFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlID09IG51bGwgPyBkdXJhdGlvbiA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZW50cnlUeXBlID09PSAnbWFyaycgfHwgZW50cnlUeXBlID09PSAnbWVhc3VyZScgPyAnY3VzdG9tJyA6ICd3ZWItdml0YWwnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9PT0gbnVsbCB8fCBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhwb3J0ZWRSZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKTtcbiAgICAgICAgICAgICAgICAoMCwgX3ZpdGFscykudHJhY2tXZWJWaXRhbE1ldHJpYyh3ZWJWaXRhbHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID0gLy8gVGhlIGRldiBzZXJ2ZXIgZmFpbHMgdG8gc2VydmUgc2NyaXB0IGFzc2V0cyB3aGVuIHRoZXJlJ3MgYSBoeWRyYXRpb25cbiAgICAgICAgICAgIC8vIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIGVudHJ5cG9pbnQuXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBoeWRyYXRlRXJyID8ge1xuICAgICAgICAgICAgICAgIGVycm9yOiBoeWRyYXRlRXJyXG4gICAgICAgICAgICB9IDogeWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChwYWdlKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcGFnZUVudHJ5cG9pbnQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDYWNoZWRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGFnZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2F0Y2hlcyBlcnJvcnMgbGlrZSB0aHJvd2luZyBpbiB0aGUgdG9wIGxldmVsIG9mIGEgbW9kdWxlXG4gICAgICAgICAgICBpbml0aWFsRXJyID0gKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycm9yKSA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yICsgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc3QgeyBnZXROb2RlRXJyb3IgIH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50Jyk7XG4gICAgICAgICAgICAvLyBTZXJ2ZXItc2lkZSBydW50aW1lIGVycm9ycyBuZWVkIHRvIGJlIHJlLXRocm93biBvbiB0aGUgY2xpZW50LXNpZGUgc29cbiAgICAgICAgICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICBpZiAoaW5pdGlhbEVycikge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRXJyID09PSBoeWRyYXRlRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZXJyb3Igb2JqZWN0LiBXZSBgdGhyb3dgIGl0IGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvdmVycmlkZGVuIHdoZW4gd2UgcmUtdGhyb3cgaXQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluaXRpYWxFcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IGluaXRpYWxFcnIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5pdGlhbEVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9ycyBmcm9tIHRoZSBtaWRkbGV3YXJlIGFyZSByZXBvcnRlZCBhcyBjbGllbnQtc2lkZSBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBtaWRkbGV3YXJlIGlzIGNvbXBpbGVkIHVzaW5nIHRoZSBjbGllbnQgY29tcGlsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnbWlkZGxld2FyZScgaW4gaHlkcmF0ZUVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdldE5vZGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKSB7XG4gICAgICAgICAgICB5aWVsZCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShkeW5hbWljSWRzKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLnJvdXRlciA9IHJvdXRlciA9ICgwLCBfcm91dGVyMSkuY3JlYXRlUm91dGVyKHBhZ2UsIHF1ZXJ5LCBhc1BhdGgsIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wczogaHlkcmF0ZVByb3BzLFxuICAgICAgICAgICAgcGFnZUxvYWRlcixcbiAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICB3cmFwQXBwLFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRXJyLFxuICAgICAgICAgICAgaXNGYWxsYmFjazogQm9vbGVhbihpc0ZhbGxiYWNrKSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogKGluZm8sIEFwcCwgc2Nyb2xsKT0+cmVuZGVyKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIH0sIGluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgQXBwLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgIGxvY2FsZXMsXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgICAgICAgIGlzUHJldmlld1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBwcm9wczogaHlkcmF0ZVByb3BzLFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRXJyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZW5kZXIocmVuZGVyQ3R4KTtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLFxuICAgICAgICAgICAgICAgIHJlbmRlckN0eFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfaW5pdE5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGluaXROZXh0KCkge1xuICAgIHJldHVybiBfaW5pdE5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgX3JlbmRlciA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKihyZW5kZXJpbmdQcm9wcykge1xuICAgICAgICBpZiAocmVuZGVyaW5nUHJvcHMuZXJyKSB7XG4gICAgICAgICAgICB5aWVsZCByZW5kZXJFcnJvcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkIGRvUmVuZGVyKHJlbmRlcmluZ1Byb3BzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJFcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihlcnIgKyAnJyk7XG4gICAgICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICBpZiAocmVuZGVyRXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGVycm9yIGlzIGRpc3BsYXllZCBpbiB0aGUgb3ZlcmxheSBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVuZGVyRXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcmVuZGVyRXJyb3IoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICB9LCByZW5kZXJpbmdQcm9wcywge1xuICAgICAgICAgICAgICAgIGVycjogcmVuZGVyRXJyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckVycm9yKHJlbmRlckVycm9yUHJvcHMpIHtcbiAgICBjb25zdCB7IEFwcCAsIGVyciAgfSA9IHJlbmRlckVycm9yUHJvcHM7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgcnVudGltZSBlcnJvcnMgYXJlIGNhdWdodCBieSBvdXIgb3ZlcmxheVxuICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4gICAgICAgIC8vIEZJWE1FOiBsZXQncyBtYWtlIHRoaXMgcmVjb3ZlcmFibGUgKGVycm9yIGluIEdJUCBjbGllbnQtdHJhbnNpdGlvbilcbiAgICAgICAgd2VicGFja0hNUi5vblVucmVjb3ZlcmFibGVFcnJvcigpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSA8QXBwPiBzbyB0aGF0IHRoZSBgPFJlYWN0RGV2T3ZlcmxheT5gIGNhblxuICAgICAgICAvLyByZW5kZXIgaXRzZWxmLlxuICAgICAgICByZXR1cm4gZG9SZW5kZXIoe1xuICAgICAgICAgICAgQXBwOiAoKT0+bnVsbFxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb21wb25lbnQ6ICgpPT5udWxsXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBsb2cgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLCBvdGhlcndpc2UgdXNlcnMgY2FuJ3QgdHJhY2sgZG93biBpc3N1ZXMuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIGNvbnNvbGUuZXJyb3IoYEEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCwgc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvY2xpZW50LXNpZGUtZXhjZXB0aW9uLW9jY3VycmVkYCk7XG4gICAgcmV0dXJuIHBhZ2VMb2FkZXIubG9hZFBhZ2UoJy9fZXJyb3InKS50aGVuKCh7IHBhZ2U6IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0pPT57XG4gICAgICAgIHJldHVybiAobGFzdEFwcFByb3BzID09PSBudWxsIHx8IGxhc3RBcHBQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdEFwcFByb3BzLkNvbXBvbmVudCkgPT09IEVycm9yQ29tcG9uZW50ID8gaW1wb3J0KCcuLi9wYWdlcy9fZXJyb3InKS50aGVuKChtKT0+KHtcbiAgICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKSA6IHtcbiAgICAgICAgICAgIEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgc3R5bGVTaGVldHNcbiAgICAgICAgfTtcbiAgICB9KS50aGVuKCh7IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0pPT57XG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgZG8gYSBub3JtYWwgcmVuZGVyIHdpdGggdGhlIGBFcnJvckNvbXBvbmVudGAgYXMgY29tcG9uZW50LlxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGBnZXRJbml0aWFsUHJvcHNgIG9uIGBBcHBgIGJlZm9yZSBtb3VudGluZy5cbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHdyYXBBcHAoQXBwKTtcbiAgICAgICAgY29uc3QgYXBwQ3R4ID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IHBhZ2UsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgICAgICAgIEFwcFRyZWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJFcnJvclByb3BzLnByb3BzID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcyA6ICgwLCBfdXRpbHMpLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCBhcHBDdHgpKS50aGVuKChpbml0UHJvcHMpPT5kb1JlbmRlcihfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIH0sIHJlbmRlckVycm9yUHJvcHMsIHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdFByb3BzXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICB9KTtcbn1cbmxldCByZWFjdFJvb3QgPSBudWxsO1xuLy8gT24gaW5pdGlhbCByZW5kZXIgYSBoeWRyYXRlIHNob3VsZCBhbHdheXMgaGFwcGVuXG5sZXQgc2hvdWxkSHlkcmF0ZSA9IHRydWU7XG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoZG9tRWwsIGZuKSB7XG4gICAgLy8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnYmVmb3JlUmVuZGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0RWwgPSBmbihzaG91bGRIeWRyYXRlID8gbWFya0h5ZHJhdGVDb21wbGV0ZSA6IG1hcmtSZW5kZXJDb21wbGV0ZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ST09UKSB7XG4gICAgICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICAgICAgICAvLyBVbmxpa2Ugd2l0aCBjcmVhdGVSb290LCB5b3UgZG9uJ3QgbmVlZCBhIHNlcGFyYXRlIHJvb3QucmVuZGVyKCkgY2FsbCBoZXJlXG4gICAgICAgICAgICByZWFjdFJvb3QgPSBfcmVhY3REb20uZGVmYXVsdC5oeWRyYXRlUm9vdChkb21FbCwgcmVhY3RFbCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFjdFJvb3QucmVuZGVyKHJlYWN0RWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGNoZWNrIGZvciBgLmh5ZHJhdGVgIGlzIHRoZXJlIHRvIHN1cHBvcnQgUmVhY3QgYWx0ZXJuYXRpdmVzIGxpa2UgcHJlYWN0XG4gICAgICAgIGlmIChzaG91bGRIeWRyYXRlKSB7XG4gICAgICAgICAgICBfcmVhY3REb20uZGVmYXVsdC5oeWRyYXRlKHJlYWN0RWwsIGRvbUVsKTtcbiAgICAgICAgICAgIHNob3VsZEh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZWFjdERvbS5kZWZhdWx0LnJlbmRlcihyZWFjdEVsLCBkb21FbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyaygnYWZ0ZXJIeWRyYXRlJykgLy8gbWFyayBlbmQgb2YgaHlkcmF0aW9uXG4gICAgO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtYmVmb3JlLWh5ZHJhdGlvbicsICduYXZpZ2F0aW9uU3RhcnQnLCAnYmVmb3JlUmVuZGVyJyk7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVySHlkcmF0ZScpO1xuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdOZXh0LmpzLWh5ZHJhdGlvbicpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKSB7XG4gICAgaWYgKCFfdXRpbHMuU1QpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKCdhZnRlclJlbmRlcicpIC8vIG1hcmsgZW5kIG9mIHJlbmRlclxuICAgIDtcbiAgICBjb25zdCBuYXZTdGFydEVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdyb3V0ZUNoYW5nZScsICdtYXJrJyk7XG4gICAgaWYgKCFuYXZTdGFydEVudHJpZXMubGVuZ3RoKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJywgbmF2U3RhcnRFbnRyaWVzWzBdLm5hbWUsICdiZWZvcmVSZW5kZXInKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJlbmRlcicsICdiZWZvcmVSZW5kZXInLCAnYWZ0ZXJSZW5kZXInKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yZW5kZXInKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbiAgICBbXG4gICAgICAgICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLFxuICAgICAgICAnTmV4dC5qcy1yZW5kZXInXG4gICAgXS5mb3JFYWNoKChtZWFzdXJlKT0+cGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlKVxuICAgICk7XG59XG5mdW5jdGlvbiBjbGVhck1hcmtzKCkge1xuICAgIFtcbiAgICAgICAgJ2JlZm9yZVJlbmRlcicsXG4gICAgICAgICdhZnRlckh5ZHJhdGUnLFxuICAgICAgICAnYWZ0ZXJSZW5kZXInLFxuICAgICAgICAncm91dGVDaGFuZ2UnXG4gICAgXS5mb3JFYWNoKChtYXJrKT0+cGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKVxuICAgICk7XG59XG5mdW5jdGlvbiBBcHBDb250YWluZXIoeyBjaGlsZHJlbiAgfSkge1xuICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCB7XG4gICAgICAgIGZuOiAoZXJyb3IpPT5yZW5kZXJFcnJvcih7XG4gICAgICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnJvclxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PmNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLCBlcnIpXG4gICAgICAgICAgICApXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZXJDb250ZXh0LlJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6ICgwLCBfcm91dGVyMSkubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGhlYWRNYW5hZ2VyXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9zdHlsZWRKc3guU3R5bGVSZWdpc3RyeSwgbnVsbCwgY2hpbGRyZW4pKSkpKTtcbn1cbmNvbnN0IHdyYXBBcHAgPSAoQXBwKT0+KHdyYXBwZWRBcHBQcm9wcyk9PntcbiAgICAgICAgY29uc3QgYXBwUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgfSwgd3JhcHBlZEFwcFByb3BzLCB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIGVycjogaHlkcmF0ZUVycixcbiAgICAgICAgICAgIHJvdXRlclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHBDb250YWluZXIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHAsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB9LCBhcHBQcm9wcykpKSk7XG4gICAgfVxuO1xubGV0IFJTQ0NvbXBvbmVudDtcbmlmIChwcm9jZXNzLmVudi5fX05FWFRfUlNDKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgY29uc3QgcnNjQ2FjaGUgPSBjcmVhdGVSZXNwb25zZUNhY2hlKCk7XG4gICAgY29uc3QgUlNDV3JhcHBlciA9ICh7IGNhY2hlS2V5ICwgc2VyaWFsaXplZCAsIF9mcmVzaCAgfSk9PntcbiAgICAgICAgY29uc3QgeyBjcmVhdGVGcm9tRmV0Y2ggLCAgfSA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2snKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gcnNjQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gY2FjaGUsIG9yIHRoZXJlIGlzIHNlcmlhbGl6ZWQgZGF0YSBhbHJlYWR5XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gY3JlYXRlRnJvbUZldGNoKHNlcmlhbGl6ZWQgPyAoKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICAgICAgICAgIHQud3JpdGFibGUuZ2V0V3JpdGVyKCkud3JpdGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdC5yZWFkYWJsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKSA6ICgoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHRSZXFVcmwgPSBsb2NhdGlvbi5wYXRobmFtZSArIHNlYXJjaCArIChzZWFyY2ggPyAnJl9fZmxpZ2h0X18nIDogJz9fX2ZsaWdodF9fJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoKGZsaWdodFJlcVVybCk7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgIHJzY0NhY2hlLnNldChjYWNoZUtleSwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3QgPSByZXNwb25zZS5yZWFkUm9vdCgpO1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIFJTQ0NvbXBvbmVudCA9IChwcm9wcyk9PntcbiAgICAgICAgY29uc3QgeyBhc1BhdGg6IGNhY2hlS2V5ICB9ID0gKDAsIF9yb3V0ZXIxKS51c2VSb3V0ZXIoKTtcbiAgICAgICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IG51bGxcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJTQ1dyYXBwZXIsIHtcbiAgICAgICAgICAgIGNhY2hlS2V5OiBjYWNoZUtleSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHByb3BzLl9fZmxpZ2h0X3NlcmlhbGl6ZWRfXyxcbiAgICAgICAgICAgIF9mcmVzaDogcHJvcHMuX19mbGlnaHRfZnJlc2hfX1xuICAgICAgICB9KSkpO1xuICAgIH07XG59XG5sZXQgbGFzdEFwcFByb3BzO1xuZnVuY3Rpb24gZG9SZW5kZXIoaW5wdXQpIHtcbiAgICBsZXQgeyBBcHAgLCBDb21wb25lbnQgLCBwcm9wcyAsIGVyciAsIF9fTl9SU0MgIH0gPSBpbnB1dDtcbiAgICBsZXQgc3R5bGVTaGVldHMgPSAnaW5pdGlhbCcgaW4gaW5wdXQgPyB1bmRlZmluZWQgOiBpbnB1dC5zdHlsZVNoZWV0cztcbiAgICBDb21wb25lbnQgPSBDb21wb25lbnQgfHwgbGFzdEFwcFByb3BzLkNvbXBvbmVudDtcbiAgICBwcm9wcyA9IHByb3BzIHx8IGxhc3RBcHBQcm9wcy5wcm9wcztcbiAgICBjb25zdCBpc1JTQyA9IHByb2Nlc3MuZW52Ll9fTkVYVF9SU0MgJiYgJ2luaXRpYWwnIGluIGlucHV0ID8gISFyc2MgOiAhIV9fTl9SU0M7XG4gICAgY29uc3QgYXBwUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICB9LCBwcm9wcywge1xuICAgICAgICBDb21wb25lbnQ6IGlzUlNDID8gUlNDQ29tcG9uZW50IDogQ29tcG9uZW50LFxuICAgICAgICBlcnIsXG4gICAgICAgIHJvdXRlclxuICAgIH0pO1xuICAgIC8vIGxhc3RBcHBQcm9wcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSBSZWFjdERvbS5yZW5kZXIgdG8gYWNjb3VudCBmb3IgUmVhY3REb20gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgbGFzdEFwcFByb3BzID0gYXBwUHJvcHM7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgIGNvbnN0IHJlbmRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBpZiAobGFzdFJlbmRlclJlamVjdCkge1xuICAgICAgICAgICAgbGFzdFJlbmRlclJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVQcm9taXNlID0gKCk9PntcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NhbmNlbCByZW5kZXJpbmcgcm91dGUnKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGFzIGEgcmV0dXJuIHR5cGUgdG8gZW5zdXJlIGl0IGRvZXNuJ3Qgc3RhcnQgcmV0dXJuaW5nIGFcbiAgICAvLyBQcm9taXNlLiBJdCBzaG91bGQgcmVtYWluIHN5bmNocm9ub3VzLlxuICAgIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIGlmICghc3R5bGVTaGVldHMgfHwgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IG5ldyBTZXQoY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZyk9PnRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJylcbiAgICAgICAgKSk7XG4gICAgICAgIGNvbnN0IG5vc2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignbm9zY3JpcHRbZGF0YS1uLWNzc10nKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBub3NjcmlwdCA9PT0gbnVsbCB8fCBub3NjcmlwdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9zY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLW4tY3NzJyk7XG4gICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiAsIHRleHQgIH0pPT57XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRIcmVmcy5oYXMoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicsIGhyZWYpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpO1xuICAgICAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25IZWFkQ29tbWl0KCkge1xuICAgICAgICBpZiAoLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIC8vIFdlIGNhbiBza2lwIHRoaXMgZHVyaW5nIGh5ZHJhdGlvbi4gUnVubmluZyBpdCB3b250IGNhdXNlIGFueSBoYXJtLCBidXRcbiAgICAgICAgLy8gd2UgbWF5IGFzIHdlbGwgc2F2ZSB0aGUgQ1BVIGN5Y2xlczpcbiAgICAgICAgc3R5bGVTaGVldHMgJiYgLy8gRW5zdXJlIHRoaXMgcmVuZGVyIHdhcyBub3QgY2FuY2VsZWRcbiAgICAgICAgIWNhbmNlbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNpcmVkSHJlZnMgPSBuZXcgU2V0KHN0eWxlU2hlZXRzLm1hcCgocyk9PnMuaHJlZlxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2RhdGEtbi1ocmVmXScpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gVG9nZ2xlIGA8c3R5bGU+YCB0YWdzIG9uIG9yIG9mZiBkZXBlbmRpbmcgb24gaWYgdGhleSdyZSBuZWVkZWQ6XG4gICAgICAgICAgICBmb3IobGV0IGlkeCA9IDA7IGlkeCA8IGN1cnJlbnRIcmVmcy5sZW5ndGg7ICsraWR4KXtcbiAgICAgICAgICAgICAgICBpZiAoZGVzaXJlZEhyZWZzLmhhcyhjdXJyZW50SHJlZnNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGVUYWdzW2lkeF0uc2V0QXR0cmlidXRlKCdtZWRpYScsICd4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVvcmRlciBzdHlsZXMgaW50byBpbnRlbmRlZCBvcmRlcjpcbiAgICAgICAgICAgIGxldCByZWZlcmVuY2VOb2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignbm9zY3JpcHRbZGF0YS1uLWNzc10nKTtcbiAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICByZWZlcmVuY2VOb2RlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMuZm9yRWFjaCgoeyBocmVmICB9KT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRUYWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdHlsZVtkYXRhLW4taHJlZj1cIiR7aHJlZn1cIl1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC8vIFRoaXMgc2hvdWxkIGJlIGFuIGludmFyaWFudDpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhcmdldFRhZywgcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlID0gdGFyZ2V0VGFnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCBjbGVhbiB1cCBzZXJ2ZXIgcmVuZGVyZWQgc3R5bGVzaGVldHM6XG4gICAgICAgICAgICBsb29zZVRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGlua1tkYXRhLW4tcF0nKSkuZm9yRWFjaCgoZWwpPT57XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuc2Nyb2xsKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oaW5wdXQuc2Nyb2xsLngsIGlucHV0LnNjcm9sbC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblJvb3RDb21taXQoKSB7XG4gICAgICAgIHJlc29sdmVQcm9taXNlKCk7XG4gICAgfVxuICAgIG9uU3RhcnQoKTtcbiAgICBjb25zdCBlbGVtID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSGVhZCwge1xuICAgICAgICBjYWxsYmFjazogb25IZWFkQ29tbWl0XG4gICAgfSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHBDb250YWluZXIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHAsIE9iamVjdC5hc3NpZ24oe1xuICAgIH0sIGFwcFByb3BzKSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcG9ydGFsLlBvcnRhbCwge1xuICAgICAgICB0eXBlOiBcIm5leHQtcm91dGUtYW5ub3VuY2VyXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JvdXRlQW5ub3VuY2VyLlJvdXRlQW5ub3VuY2VyLCBudWxsKSkpKTtcbiAgICAvLyBXZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgICByZW5kZXJSZWFjdEVsZW1lbnQoYXBwRWxlbWVudCwgKGNhbGxiYWNrKT0+LyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJvb3QsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogW1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG9uUm9vdENvbW1pdFxuICAgICAgICAgICAgXVxuICAgICAgICB9LCBwcm9jZXNzLmVudi5fX05FWFRfU1RSSUNUX01PREUgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3RyaWN0TW9kZSwgbnVsbCwgZWxlbSkgOiBlbGVtKVxuICAgICk7XG4gICAgcmV0dXJuIHJlbmRlclByb21pc2U7XG59XG5mdW5jdGlvbiBSb290KHsgY2FsbGJhY2tzICwgY2hpbGRyZW4gIH0pIHtcbiAgICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFja3MgYXJlIGV4ZWN1dGVkXG4gICAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGVcbiAgICBfcmVhY3QuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3QoKCk9PmNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjayk9PmNhbGxiYWNrKClcbiAgICAgICAgKVxuICAgICwgW1xuICAgICAgICBjYWxsYmFja3NcbiAgICBdKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKSB7XG4gICAgICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIC8vIFdlIHNob3VsZCBhc2sgdG8gbWVhc3VyZSB0aGUgV2ViIFZpdGFscyBhZnRlciByZW5kZXJpbmcgY29tcGxldGVzIHNvIHdlXG4gICAgLy8gZG9uJ3QgY2F1c2UgYW55IGh5ZHJhdGlvbiBkZWxheTpcbiAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgKDAsIF9wZXJmb3JtYW5jZVJlbGF5ZXIpLmRlZmF1bHQob25QZXJmRW50cnkpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG4vLyBEdW1teSBjb21wb25lbnQgdGhhdCB3ZSByZW5kZXIgYXMgYSBjaGlsZCBvZiBSb290IHNvIHRoYXQgd2UgY2FuXG4vLyB0b2dnbGUgdGhlIGNvcnJlY3Qgc3R5bGVzIGJlZm9yZSB0aGUgcGFnZSBpcyByZW5kZXJlZC5cbmZ1bmN0aW9uIEhlYWQoeyBjYWxsYmFjayAgfSkge1xuICAgIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkXG4gICAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT5jYWxsYmFjaygpXG4gICAgLCBbXG4gICAgICAgIGNhbGxiYWNrXG4gICAgXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXROZXh0IiwicmVuZGVyIiwicmVuZGVyRXJyb3IiLCJlbWl0dGVyIiwicm91dGVyIiwidmVyc2lvbiIsInJlcXVpcmUiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3JlYWN0RG9tIiwiX3N0eWxlZEpzeCIsIl9oZWFkTWFuYWdlckNvbnRleHQiLCJfbWl0dCIsIl9yb3V0ZXJDb250ZXh0IiwiX3JvdXRlciIsIl9pc0R5bmFtaWMiLCJfcXVlcnlzdHJpbmciLCJfcnVudGltZUNvbmZpZyIsIl91dGlscyIsIl9wb3J0YWwiLCJfaGVhZE1hbmFnZXIiLCJfcGFnZUxvYWRlciIsIl9wZXJmb3JtYW5jZVJlbGF5ZXIiLCJfcm91dGVBbm5vdW5jZXIiLCJfcm91dGVyMSIsIl9pc0Vycm9yIiwiX3ZpdGFscyIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJlcnJvciIsImRvbmUiLCJQcm9taXNlIiwidGhlbiIsIl9hc3luY1RvR2VuZXJhdG9yIiwiZm4iLCJzZWxmIiwiYXJncyIsImFyZ3VtZW50cyIsImFwcGx5IiwiZXJyIiwidW5kZWZpbmVkIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19lc01vZHVsZSIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwibmV3T2JqIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsInNldCIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwibGVuZ3RoIiwic291cmNlIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJjb25jYXQiLCJmaWx0ZXIiLCJzeW0iLCJmb3JFYWNoIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJ0ZXh0Q29udGVudCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJsb29zZVRvQXJyYXkiLCJpbnB1dCIsInNsaWNlIiwiaHlkcmF0ZVByb3BzIiwicHJvcHMiLCJoeWRyYXRlRXJyIiwicGFnZSIsInF1ZXJ5IiwiYnVpbGRJZCIsImFzc2V0UHJlZml4IiwicnVudGltZUNvbmZpZyIsImR5bmFtaWNJZHMiLCJpc0ZhbGxiYWNrIiwibG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJyc2MiLCJkZWZhdWx0TG9jYWxlIiwicHJlZml4IiwiX193ZWJwYWNrX3B1YmxpY19wYXRoX18iLCJzZXRDb25maWciLCJzZXJ2ZXJSdW50aW1lQ29uZmlnIiwicHVibGljUnVudGltZUNvbmZpZyIsImFzUGF0aCIsImdldFVSTCIsImhhc0Jhc2VQYXRoIiwiZGVsQmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwYXJzZVJlbGF0aXZlVXJsIiwiZm9ybWF0VXJsIiwicGFyc2VkQXMiLCJsb2NhbGVQYXRoUmVzdWx0IiwicGF0aG5hbWUiLCJkZXRlY3RlZExvY2FsZSIsImRldGVjdGVkRG9tYWluIiwiX19ORVhUX0kxOE5fRE9NQUlOUyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJzY3JpcHRMb2FkZXIiLCJpbml0U2NyaXB0TG9hZGVyIiwicGFnZUxvYWRlciIsInJlZ2lzdGVyIiwiciIsImYiLCJyb3V0ZUxvYWRlciIsIm9uRW50cnlwb2ludCIsIl9fTkVYVF9QIiwibWFwIiwicCIsInNldFRpbWVvdXQiLCJwdXNoIiwiaGVhZE1hbmFnZXIiLCJhcHBFbGVtZW50IiwibGFzdFJlbmRlclJlamVjdCIsIndlYnBhY2tITVIiLCJDYWNoZWRBcHAiLCJvblBlcmZFbnRyeSIsImdldElzU3NyIiwiaXNTc3IiLCJDb250YWluZXIiLCJjb21wb25lbnRFcnIiLCJzY3JvbGxUb0hhc2giLCJuZXh0RXhwb3J0IiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2giLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiX2giLCJzaGFsbG93IiwiaGFzaCIsInN1YnN0cmluZyIsImVsIiwic2Nyb2xsSW50b1ZpZXciLCJjaGlsZHJlbiIsIlJlYWN0RGV2T3ZlcmxheSIsImNyZWF0ZUVsZW1lbnQiLCJDb21wb25lbnQiLCJDYWNoZWRDb21wb25lbnQiLCJfaW5pdE5leHQiLCJvcHRzIiwiaW5pdGlhbEVyciIsIndoZW5FbnRyeXBvaW50IiwiYXBwRW50cnlwb2ludCIsImFwcCIsImNvbXBvbmVudCIsIm1vZCIsImV4cG9ydGVkUmVwb3J0V2ViVml0YWxzIiwicmVwb3J0V2ViVml0YWxzIiwiaWQiLCJuYW1lIiwic3RhcnRUaW1lIiwiZHVyYXRpb24iLCJlbnRyeVR5cGUiLCJlbnRyaWVzIiwidW5pcXVlSUQiLCJEYXRlIiwibm93IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJ3ZWJWaXRhbHMiLCJsYWJlbCIsInRyYWNrV2ViVml0YWxNZXRyaWMiLCJwYWdlRW50cnlwb2ludCIsImlzVmFsaWRFbGVtZW50VHlwZSIsIkVycm9yIiwiZ2V0Tm9kZUVycm9yIiwibWVzc2FnZSIsImUiLCJzdGFjayIsIm5vZGUiLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiY3JlYXRlUm91dGVyIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsIkJvb2xlYW4iLCJzdWJzY3JpcHRpb24iLCJzY3JvbGwiLCJyZW5kZXJDdHgiLCJpbml0aWFsIiwiX3JlbmRlciIsInJlbmRlcmluZ1Byb3BzIiwiZG9SZW5kZXIiLCJyZW5kZXJFcnIiLCJjYW5jZWxsZWQiLCJyZW5kZXJFcnJvclByb3BzIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJzdHlsZVNoZWV0cyIsImNvbnNvbGUiLCJsb2FkUGFnZSIsIkVycm9yQ29tcG9uZW50IiwibGFzdEFwcFByb3BzIiwibSIsIkFwcFRyZWUiLCJhcHBDdHgiLCJjdHgiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwicmVhY3RSb290Iiwic2hvdWxkSHlkcmF0ZSIsInJlbmRlclJlYWN0RWxlbWVudCIsImRvbUVsIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJyZWFjdEVsIiwibWFya0h5ZHJhdGVDb21wbGV0ZSIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIl9fTkVYVF9SRUFDVF9ST09UIiwiaHlkcmF0ZVJvb3QiLCJoeWRyYXRlIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJjbGVhck1hcmtzIiwibmF2U3RhcnRFbnRyaWVzIiwiY2xlYXJNZWFzdXJlcyIsIkFwcENvbnRhaW5lciIsIlJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsIm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIlN0eWxlUmVnaXN0cnkiLCJ3cmFwcGVkQXBwUHJvcHMiLCJhcHBQcm9wcyIsIlJTQ0NvbXBvbmVudCIsIl9fTkVYVF9SU0MiLCJjcmVhdGVSZXNwb25zZUNhY2hlIiwiTWFwIiwicnNjQ2FjaGUiLCJSU0NXcmFwcGVyIiwiY2FjaGVLZXkiLCJzZXJpYWxpemVkIiwiX2ZyZXNoIiwiY3JlYXRlRnJvbUZldGNoIiwicmVzcG9uc2UiLCJ0IiwiVHJhbnNmb3JtU3RyZWFtIiwiZ2V0V3JpdGVyIiwid3JpdGUiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJvZHkiLCJyZWFkYWJsZSIsImZsaWdodFJlcVVybCIsImZldGNoIiwicm9vdCIsInJlYWRSb290IiwidXNlUm91dGVyIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsIl9fZmxpZ2h0X3NlcmlhbGl6ZWRfXyIsIl9fZmxpZ2h0X2ZyZXNoX18iLCJfX05fUlNDIiwiaXNSU0MiLCJjYW5jZWxlZCIsInJlc29sdmVQcm9taXNlIiwicmVuZGVyUHJvbWlzZSIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwib25IZWFkQ29tbWl0IiwiZGVzaXJlZEhyZWZzIiwicyIsImlkeCIsInJlbW92ZUF0dHJpYnV0ZSIsInJlZmVyZW5jZU5vZGUiLCJ0YXJnZXRUYWciLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwibmV4dFNpYmxpbmciLCJyZW1vdmVDaGlsZCIsInNjcm9sbFRvIiwieCIsInkiLCJvblJvb3RDb21taXQiLCJlbGVtIiwiRnJhZ21lbnQiLCJIZWFkIiwiY2FsbGJhY2siLCJQb3J0YWwiLCJ0eXBlIiwiUm91dGVBbm5vdW5jZXIiLCJSb290IiwiY2FsbGJhY2tzIiwiX19ORVhUX1NUUklDVF9NT0RFIiwiU3RyaWN0TW9kZSIsInVzZUxheW91dEVmZmVjdCIsIl9fTkVYVF9URVNUX01PREUiLCJ1c2VFZmZlY3QiLCJfX05FWFRfSFlEUkFURUQiLCJfX05FWFRfSFlEUkFURURfQ0IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nvar _ = __webpack_require__(/*! ./ */ \"./node_modules/next/dist/client/index.js\");\n\nvar _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\n\nvar _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ \"./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js\"));\n\nvar _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ \"./node_modules/next/dist/client/dev/dev-build-watcher.js\"));\n\nvar _fouc = __webpack_require__(/*! ./dev/fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\n\nvar _websocket = __webpack_require__(/*! ./dev/error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\n\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n} // Temporary workaround for the issue described here:\n// https://github.com/vercel/next.js/issues/3775#issuecomment-407438123\n// The runtimeChunk doesn't have dynamic import handling code when there hasn't been a dynamic import\n// The runtimeChunk can't hot reload itself currently to correct it when adding pages using on-demand-entries\n// eslint-disable-next-line no-unused-expressions\n\n\n__webpack_require__.e(/*! import() */ \"node_modules_next_dist_client_dev_noop_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./dev/noop */ \"./node_modules/next/dist/client/dev/noop.js\", 23));\n;\nvar _window = window,\n    assetPrefix = _window.__NEXT_DATA__.assetPrefix;\nvar prefix = assetPrefix || '';\nvar webpackHMR = (0, _webpackHotMiddlewareClient)[\"default\"]();\n(0, _websocket).connectHMR({\n  assetPrefix: prefix,\n  path: '/_next/webpack-hmr'\n});\nwindow.next = {\n  version: _.version,\n\n  // router is initialized later so it has to be live-binded\n  get router() {\n    return _.router;\n  },\n\n  emitter: _.emitter,\n  render: _.render,\n  renderError: _.renderError\n};\n(0, _).initNext({\n  webpackHMR: webpackHMR\n}).then(function (_ref) {\n  var renderCtx = _ref.renderCtx;\n  (0, _onDemandEntriesClient)[\"default\"]();\n\n  var buildIndicatorHandler = function buildIndicatorHandler() {};\n\n  function devPagesManifestListener(event) {\n    if (event.data.indexOf('devPagesManifest') !== -1) {\n      fetch(\"\".concat(prefix, \"/_next/static/development/_devPagesManifest.json\")).then(function (res) {\n        return res.json();\n      }).then(function (manifest) {\n        window.__DEV_PAGES_MANIFEST = manifest;\n      })[\"catch\"](function (err) {\n        console.log(\"Failed to fetch devPagesManifest\", err);\n      });\n    } else if (event.data.indexOf('middlewareChanges') !== -1) {\n      return window.location.reload();\n    } else if (event.data.indexOf('serverOnlyChanges') !== -1) {\n      var _JSON$parse = JSON.parse(event.data),\n          pages = _JSON$parse.pages; // Make sure to reload when the dev-overlay is showing for an\n      // API route\n\n\n      if (pages.includes(_.router.query.__NEXT_PAGE)) {\n        return window.location.reload();\n      }\n\n      if (!_.router.clc && pages.includes(_.router.pathname)) {\n        console.log('Refreshing page data due to server-side change');\n        buildIndicatorHandler('building');\n\n        var clearIndicator = function clearIndicator() {\n          return buildIndicatorHandler('built');\n        };\n\n        _.router.replace(_.router.pathname + '?' + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(_.router.query), new URLSearchParams(location.search))), _.router.asPath)[\"finally\"](clearIndicator);\n      }\n    }\n  }\n\n  (0, _websocket).addMessageListener(devPagesManifestListener);\n\n  if (true) {\n    (0, _devBuildWatcher)[\"default\"](function (handler) {\n      buildIndicatorHandler = handler;\n    }, \"bottom-right\");\n  } // delay rendering until after styles have been applied in development\n\n\n  (0, _fouc).displayContent(function () {\n    (0, _).render(renderCtx);\n  });\n})[\"catch\"](function (err) {\n  console.error('Error was not caught', err);\n});\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9uZXh0LWRldi5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBQ2IsSUFBSUEsQ0FBQyxHQUFHQyxtQkFBTyxDQUFDLG9EQUFELENBQWY7O0FBQ0EsSUFBSUMsc0JBQXNCLEdBQUdDLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVHQUFELENBQVIsQ0FBbkQ7O0FBQ0EsSUFBSUcsMkJBQTJCLEdBQUdELHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLGlIQUFELENBQVIsQ0FBeEQ7O0FBQ0EsSUFBSUksZ0JBQWdCLEdBQUdGLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHlGQUFELENBQVIsQ0FBN0M7O0FBQ0EsSUFBSUssS0FBSyxHQUFHTCxtQkFBTyxDQUFDLCtEQUFELENBQW5COztBQUNBLElBQUlNLFVBQVUsR0FBR04sbUJBQU8sQ0FBQyxxR0FBRCxDQUF4Qjs7QUFDQSxJQUFJTyxZQUFZLEdBQUdQLG1CQUFPLENBQUMsK0dBQUQsQ0FBMUI7O0FBQ0EsU0FBU0Usc0JBQVQsQ0FBZ0NNLEdBQWhDLEVBQXFDO0FBQ2pDLFNBQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYLEdBQXdCRCxHQUF4QixHQUE4QjtBQUNqQyxlQUFTQTtBQUR3QixHQUFyQztBQUdILEVBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBcUI7QUFDckIsY0FBK0NFLE1BQS9DO0FBQUEsSUFBeUJDLFdBQXpCLFdBQVFDLGFBQVIsQ0FBeUJELFdBQXpCO0FBQ0EsSUFBTUUsTUFBTSxHQUFHRixXQUFXLElBQUksRUFBOUI7QUFDQSxJQUFNRyxVQUFVLEdBQUcsQ0FBQyxHQUFHWCwyQkFBSixjQUFuQjtBQUNBLENBQUMsR0FBR0csVUFBSixFQUFnQlMsVUFBaEIsQ0FBMkI7QUFDdkJKLEVBQUFBLFdBQVcsRUFBRUUsTUFEVTtBQUV2QkcsRUFBQUEsSUFBSSxFQUFFO0FBRmlCLENBQTNCO0FBSUFOLE1BQU0sQ0FBQ08sSUFBUCxH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QUNnQixNQUE3QixDQUFuRixDQUFELENBQWpELEVBQTZLeEQsQ0FBQyxDQUFDb0IsTUFBRixDQUFTcUMsTUFBdEwsYUFBc01QLGNBQXRNO0FBQ0g7QUFDSjtBQUNKOztBQUNELEdBQUMsR0FBRzNDLFVBQUosRUFBZ0JtRCxrQkFBaEIsQ0FBbUM5Qix3QkFBbkM7O0FBQ0EsTUFBSStCLElBQUosRUFBd0M7QUFDcEMsS0FBQyxHQUFHdEQsZ0JBQUosYUFBOEIsVUFBQ3lELE9BQUQsRUFBVztBQUNyQ25DLE1BQUFBLHFCQUFxQixHQUFHbUMsT0FBeEI7QUFDSCxLQUZELEVBRUdILGNBRkg7QUFHSCxHQW5DcUIsQ0FvQ3RCOzs7QUFDQSxHQUFDLEdBQUdyRCxLQUFKLEVBQVcwRCxjQUFYLENBQTBCLFlBQUk7QUFDMUIsS0FBQyxHQUFHaEUsQ0FBSixFQUFPc0IsTUFBUCxDQUFjSSxTQUFkO0FBQ0gsR0FGRDtBQUdILENBMUNELFdBMENTLFVBQUNXLEdBQUQsRUFBTztBQUNaQyxFQUFBQSxPQUFPLENBQUMyQixLQUFSLENBQWMsc0JBQWQsRUFBc0M1QixHQUF0QztBQUNILENBNUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25leHQtZGV2LmpzPzM1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgXyA9IHJlcXVpcmUoXCIuL1wiKTtcbnZhciBfb25EZW1hbmRFbnRyaWVzQ2xpZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50XCIpKTtcbnZhciBfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlLWNsaWVudFwiKSk7XG52YXIgX2RldkJ1aWxkV2F0Y2hlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGV2L2Rldi1idWlsZC13YXRjaGVyXCIpKTtcbnZhciBfZm91YyA9IHJlcXVpcmUoXCIuL2Rldi9mb3VjXCIpO1xudmFyIF93ZWJzb2NrZXQgPSByZXF1aXJlKFwiLi9kZXYvZXJyb3Itb3ZlcmxheS93ZWJzb2NrZXRcIik7XG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIHRoZSBpc3N1ZSBkZXNjcmliZWQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzc3NSNpc3N1ZWNvbW1lbnQtNDA3NDM4MTIzXG4vLyBUaGUgcnVudGltZUNodW5rIGRvZXNuJ3QgaGF2ZSBkeW5hbWljIGltcG9ydCBoYW5kbGluZyBjb2RlIHdoZW4gdGhlcmUgaGFzbid0IGJlZW4gYSBkeW5hbWljIGltcG9ydFxuLy8gVGhlIHJ1bnRpbWVDaHVuayBjYW4ndCBob3QgcmVsb2FkIGl0c2VsZiBjdXJyZW50bHkgdG8gY29ycmVjdCBpdCB3aGVuIGFkZGluZyBwYWdlcyB1c2luZyBvbi1kZW1hbmQtZW50cmllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuaW1wb3J0KCcuL2Rldi9ub29wJyk7O1xuY29uc3QgeyBfX05FWFRfREFUQV9fOiB7IGFzc2V0UHJlZml4ICB9ICwgIH0gPSB3aW5kb3c7XG5jb25zdCBwcmVmaXggPSBhc3NldFByZWZpeCB8fCAnJztcbmNvbnN0IHdlYnBhY2tITVIgPSAoMCwgX3dlYnBhY2tIb3RNaWRkbGV3YXJlQ2xpZW50KS5kZWZhdWx0KCk7XG4oMCwgX3dlYnNvY2tldCkuY29ubmVjdEhNUih7XG4gICAgYXNzZXRQcmVmaXg6IHByZWZpeCxcbiAgICBwYXRoOiAnL19uZXh0L3dlYnBhY2staG1yJ1xufSk7XG53aW5kb3cubmV4dCA9IHtcbiAgICB2ZXJzaW9uOiBfLnZlcnNpb24sXG4gICAgLy8gcm91dGVyIGlzIGluaXRpYWxpemVkIGxhdGVyIHNvIGl0IGhhcyB0byBiZSBsaXZlLWJpbmRlZFxuICAgIGdldCByb3V0ZXIgKCkge1xuICAgICAgICByZXR1cm4gXy5yb3V0ZXI7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBfLmVtaXR0ZXIsXG4gICAgcmVuZGVyOiBfLnJlbmRlcixcbiAgICByZW5kZXJFcnJvcjogXy5yZW5kZXJFcnJvclxufTtcbigwLCBfKS5pbml0TmV4dCh7XG4gICAgd2VicGFja0hNUlxufSkudGhlbigoeyByZW5kZXJDdHggIH0pPT57XG4gICAgKDAsIF9vbkRlbWFuZEVudHJpZXNDbGllbnQpLmRlZmF1bHQoKTtcbiAgICBsZXQgYnVpbGRJbmRpY2F0b3JIYW5kbGVyID0gKCk9PntcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdkZXZQYWdlc01hbmlmZXN0JykgIT09IC0xKSB7XG4gICAgICAgICAgICBmZXRjaChgJHtwcmVmaXh9L19uZXh0L3N0YXRpYy9kZXZlbG9wbWVudC9fZGV2UGFnZXNNYW5pZmVzdC5qc29uYCkudGhlbigocmVzKT0+cmVzLmpzb24oKVxuICAgICAgICAgICAgKS50aGVuKChtYW5pZmVzdCk9PntcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ERVZfUEFHRVNfTUFOSUZFU1QgPSBtYW5pZmVzdDtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBkZXZQYWdlc01hbmlmZXN0YCwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignbWlkZGxld2FyZUNoYW5nZXMnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdzZXJ2ZXJPbmx5Q2hhbmdlcycpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlcyAgfSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gcmVsb2FkIHdoZW4gdGhlIGRldi1vdmVybGF5IGlzIHNob3dpbmcgZm9yIGFuXG4gICAgICAgICAgICAvLyBBUEkgcm91dGVcbiAgICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhfLnJvdXRlci5xdWVyeS5fX05FWFRfUEFHRSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLnJvdXRlci5jbGMgJiYgcGFnZXMuaW5jbHVkZXMoXy5yb3V0ZXIucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlZnJlc2hpbmcgcGFnZSBkYXRhIGR1ZSB0byBzZXJ2ZXItc2lkZSBjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIoJ2J1aWxkaW5nJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYXJJbmRpY2F0b3IgPSAoKT0+YnVpbGRJbmRpY2F0b3JIYW5kbGVyKCdidWlsdCcpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIF8ucm91dGVyLnJlcGxhY2UoXy5yb3V0ZXIucGF0aG5hbWUgKyAnPycgKyBTdHJpbmcoKDAsIF9xdWVyeXN0cmluZykuYXNzaWduKCgwLCBfcXVlcnlzdHJpbmcpLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMoXy5yb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgXy5yb3V0ZXIuYXNQYXRoKS5maW5hbGx5KGNsZWFySW5kaWNhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKGRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lcik7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9CVUlMRF9JTkRJQ0FUT1IpIHtcbiAgICAgICAgKDAsIF9kZXZCdWlsZFdhdGNoZXIpLmRlZmF1bHQoKGhhbmRsZXIpPT57XG4gICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB9LCBwcm9jZXNzLmVudi5fX05FWFRfQlVJTERfSU5ESUNBVE9SX1BPU0lUSU9OKTtcbiAgICB9XG4gICAgLy8gZGVsYXkgcmVuZGVyaW5nIHVudGlsIGFmdGVyIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZCBpbiBkZXZlbG9wbWVudFxuICAgICgwLCBfZm91YykuZGlzcGxheUNvbnRlbnQoKCk9PntcbiAgICAgICAgKDAsIF8pLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgIH0pO1xufSkuY2F0Y2goKGVycik9PntcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3YXMgbm90IGNhdWdodCcsIGVycik7XG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC1kZXYuanMubWFwIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX29uRGVtYW5kRW50cmllc0NsaWVudCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQiLCJfZGV2QnVpbGRXYXRjaGVyIiwiX2ZvdWMiLCJfd2Vic29ja2V0IiwiX3F1ZXJ5c3RyaW5nIiwib2JqIiwiX19lc01vZHVsZSIsIndpbmRvdyIsImFzc2V0UHJlZml4IiwiX19ORVhUX0RBVEFfXyIsInByZWZpeCIsIndlYnBhY2tITVIiLCJjb25uZWN0SE1SIiwicGF0aCIsIm5leHQiLCJ2ZXJzaW9uIiwicm91dGVyIiwiZW1pdHRlciIsInJlbmRlciIsInJlbmRlckVycm9yIiwiaW5pdE5leHQiLCJ0aGVuIiwicmVuZGVyQ3R4IiwiYnVpbGRJbmRpY2F0b3JIYW5kbGVyIiwiZGV2UGFnZXNNYW5pZmVzdExpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiaW5kZXhPZiIsImZldGNoIiwicmVzIiwianNvbiIsIm1hbmlmZXN0IiwiX19ERVZfUEFHRVNfTUFOSUZFU1QiLCJlcnIiLCJjb25zb2xlIiwibG9nIiwibG9jYXRpb24iLCJyZWxvYWQiLCJKU09OIiwicGFyc2UiLCJwYWdlcyIsImluY2x1ZGVzIiwicXVlcnkiLCJfX05FWFRfUEFHRSIsImNsYyIsInBhdGhuYW1lIiwiY2xlYXJJbmRpY2F0b3IiLCJyZXBsYWNlIiwiU3RyaW5nIiwiYXNzaWduIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsImFzUGF0aCIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQlVJTERfSU5ESUNBVE9SIiwiaGFuZGxlciIsIl9fTkVYVF9CVUlMRF9JTkRJQ0FUT1JfUE9TSVRJT04iLCJkaXNwbGF5Q29udGVudCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/next-dev.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck */ \"./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/createClass */ \"./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\n\nvar _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\n\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parseRelativeUrl = __webpack_require__(/*! ../shared/lib/router/utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\n\nvar _routeLoader = __webpack_require__(/*! ./route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\".concat(route, \"\\\"\"));\n  }\n\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\n\nvar PageLoader = /*#__PURE__*/function () {\n  function PageLoader(buildId, assetPrefix) {\n    _classCallCheck(this, PageLoader);\n\n    this.routeLoader = (0, _routeLoader).createRouteLoader(assetPrefix);\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    /** @type {Promise<Set<string>>} */\n\n    this.promisedSsgManifest = new Promise(function (resolve) {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        window.__SSG_MANIFEST_CB = function () {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  }\n\n  _createClass(PageLoader, [{\n    key: \"getPageList\",\n    value: function getPageList() {\n      if (false) {} else {\n        if (window.__DEV_PAGES_MANIFEST) {\n          return window.__DEV_PAGES_MANIFEST.pages;\n        } else {\n          if (!this.promisedDevPagesManifest) {\n            this.promisedDevPagesManifest = fetch(\"\".concat(this.assetPrefix, \"/_next/static/development/_devPagesManifest.json\")).then(function (res) {\n              return res.json();\n            }).then(function (manifest) {\n              window.__DEV_PAGES_MANIFEST = manifest;\n              return manifest.pages;\n            })[\"catch\"](function (err) {\n              console.log(\"Failed to fetch devPagesManifest\", err);\n            });\n          }\n\n          return this.promisedDevPagesManifest;\n        }\n      }\n    }\n  }, {\n    key: \"getMiddlewareList\",\n    value: function getMiddlewareList() {\n      if (false) {} else {\n        if (window.__DEV_MIDDLEWARE_MANIFEST) {\n          return window.__DEV_MIDDLEWARE_MANIFEST;\n        } else {\n          if (!this.promisedMiddlewareManifest) {\n            this.promisedMiddlewareManifest = fetch(\"\".concat(this.assetPrefix, \"/_next/static/\").concat(this.buildId, \"/_devMiddlewareManifest.json\")).then(function (res) {\n              return res.json();\n            }).then(function (manifest) {\n              window.__DEV_MIDDLEWARE_MANIFEST = manifest;\n              return manifest;\n            })[\"catch\"](function (err) {\n              console.log(\"Failed to fetch _devMiddlewareManifest\", err);\n            });\n          }\n\n          return this.promisedMiddlewareManifest;\n        }\n      }\n    }\n    /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    * @returns {string}\n    */\n\n  }, {\n    key: \"getDataHref\",\n    value: function getDataHref(_ref) {\n      var _this = this;\n\n      var href = _ref.href,\n          asPath = _ref.asPath,\n          ssg = _ref.ssg,\n          rsc = _ref.rsc,\n          locale = _ref.locale;\n\n      var _parseRelativeUrl2 = (0, _parseRelativeUrl).parseRelativeUrl(href),\n          hrefPathname = _parseRelativeUrl2.pathname,\n          query = _parseRelativeUrl2.query,\n          search = _parseRelativeUrl2.search;\n\n      var _parseRelativeUrl3 = (0, _parseRelativeUrl).parseRelativeUrl(asPath),\n          asPathname = _parseRelativeUrl3.pathname;\n\n      var route = normalizeRoute(hrefPathname);\n\n      var getHrefForSlug = function getHrefForSlug(path) {\n        if (rsc) return path + '?__flight__';\n        var dataRoute = (0, _getAssetPathFromRoute)[\"default\"]((0, _normalizeTrailingSlash).removePathTrailingSlash((0, _router).addLocale(path, locale)), '.json');\n        return (0, _router).addBasePath(\"/_next/data/\".concat(_this.buildId).concat(dataRoute).concat(ssg ? '' : search));\n      };\n\n      var isDynamic = (0, _isDynamic).isDynamicRoute(route);\n      var interpolatedRoute = isDynamic ? (0, _router).interpolateAs(hrefPathname, asPathname, query).result : '';\n      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n    }\n    /**\n    * @param {string} route - the route (file-system path)\n    */\n\n  }, {\n    key: \"_isSsg\",\n    value: function _isSsg(route) {\n      return this.promisedSsgManifest.then(function (s) {\n        return s.has(route);\n      });\n    }\n  }, {\n    key: \"loadPage\",\n    value: function loadPage(route) {\n      return this.routeLoader.loadRoute(route).then(function (res) {\n        if ('component' in res) {\n          return {\n            page: res.component,\n            mod: res.exports,\n            styleSheets: res.styles.map(function (o) {\n              return {\n                href: o.href,\n                text: o.content\n              };\n            })\n          };\n        }\n\n        throw res.error;\n      });\n    }\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(route) {\n      return this.routeLoader.prefetch(route);\n    }\n  }]);\n\n  return PageLoader;\n}();\n\nexports[\"default\"] = PageLoader;\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wYWdlLWxvYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7Ozs7OztBQUNiQSw4Q0FBNkM7QUFDekNHLEVBQUFBLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxrQkFBQSxHQUFrQixLQUFLLENBQXZCOztBQUNBLElBQUlFLE9BQU8sR0FBR0MsbUJBQU8sQ0FBQyx5RkFBRCxDQUFyQjs7QUFDQSxJQUFJQyxzQkFBc0IsR0FBR0Msc0JBQXNCLENBQUNGLG1CQUFPLENBQUMsMklBQUQsQ0FBUixDQUFuRDs7QUFDQSxJQUFJRyxVQUFVLEdBQUdILG1CQUFPLENBQUMsNkdBQUQsQ0FBeEI7O0FBQ0EsSUFBSUksaUJBQWlCLEdBQUdKLG1CQUFPLENBQUMsNkhBQUQsQ0FBL0I7O0FBQ0EsSUFBSUssdUJBQXVCLEdBQUdMLG1CQUFPLENBQUMsK0ZBQUQsQ0FBckM7O0FBQ0EsSUFBSU0sWUFBWSxHQUFHTixtQkFBTyxDQUFDLHVFQUFELENBQTFCOztBQUNBLFNBQVNFLHNCQUFULENBQWdDSyxHQUFoQyxFQUFxQztBQUNqQyxTQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBWCxHQUF3QkQsR0FBeEIsR0FBOEI7QUFDakMsZUFBU0E7QUFEd0IsR0FBckM7QUFHSDs7QUFDRCxTQUFTRSxjQUFULENBQXdCQyxLQUF4QixFQUErQjtBQUMzQixNQUFJQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWEsR0FBakIsRUFBc0I7QUFDbEIsVUFBTSxJQUFJQyxLQUFKLHVEQUFzREQsS0FBdEQsUUFBTjtBQUNIOztBQUNELE1BQUlBLEtBQUssS0FBSyxHQUFkLEVBQW1CLE9BQU9BLEtBQVA7QUFDbkIsU0FBT0EsS0FBSyxDQUFDRSxPQUFOLENBQWMsS0FBZCxFQUFxQixFQUFyQixDQUFQO0FBQ0g7O0lBQ0tDO0FBb0ZGLHNCQUFZQyxPQUFaLEVBQXFCQyxXQUFyQixFQUFpQztBQUFBOztBQUM3QixTQUFLQyxXQUFMLEdBQW1CLENBQUMsR0FBR1YsWUFBSixFQUFrQlcsaUJBQWxCLENBQW9DRixXQUFwQyxDQUFuQjtBQUNBLFNBQUtELE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLFdBQUwsR0FBbUJBLFdBQW5CO0FBQ0E7O0FBQW9DLFNBQUtHLG1CQUFMLEdBQTJCLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVc7QUFDbEYsVUFBSUMsTUFBTSxDQUFDQyxjQUFYLEVBQTJCO0FBQ3ZCRixRQUFBQSxPQUFPLENBQUNDLE1BQU0sQ0FBQ0MsY0FBUixDQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0hELFFBQUFBLE1BQU0sQ0FBQ0UsaUJBQVAsR0FBMkIsWUFBSTtBQUMzQkgsVUFBQUEsT0FBTyxDQUFDQyxNQUFNLENBQUNDLGNBQVIsQ0FBUDtBQUNILFNBRkQ7QUFHSDtBQUNKLEtBUjhELENBQTNCO0FBU3ZDOzs7O1dBaEdELHVCQUFjO0FBQ1YsaUJBQTJDLEVBQTNDLE1BR087QUFDSCxZQUFJRCxNQUFNLENBQUNPLG9CQUFYLEVBQWlDO0FBQzdCLGlCQUFPUCxNQUFNLENBQUNPLG9CQUFQLENBQTRCQyxLQUFuQztBQUNILFNBRkQsTUFFTztBQUNILGNBQUksQ0FBQyxLQUFLQyx3QkFBVixFQUFvQztBQUNoQyxpQkFBS0Esd0JBQUwsR0FBZ0NDLEtBQUssV0FBSSxLQUFLaEIsV0FBVCxzREFBTCxDQUE2RVUsSUFBN0UsQ0FBa0YsVUFBQ08sR0FBRDtBQUFBLHFCQUFPQSxHQUFHLENBQUNDLElBQUosRUFBUDtBQUFBLGFBQWxGLEVBQzlCUixJQUQ4QixDQUN6QixVQUFDQyxRQUFELEVBQVk7QUFDZkwsY0FBQUEsTUFBTSxDQUFDTyxvQkFBUCxHQUE4QkYsUUFBOUI7QUFDQSxxQkFBT0EsUUFBUSxDQUFDRyxLQUFoQjtBQUNILGFBSitCLFdBSXZCLFVBQUNLLEdBQUQsRUFBTztBQUNaQyxjQUFBQSxPQUFPLENBQUNDLEdBQVIscUNBQWdERixHQUFoRDtBQUNILGFBTitCLENBQWhDO0FBT0g7O0FBQ0QsaUJBQU8sS0FBS0osd0JBQVo7QUFDSDtBQUNKO0FBQ0o7OztXQUNELDZCQUFvQjtBQUNoQixpQkFBMkMsRUFBM0MsTUFFTztBQUNILFlBQUlULE1BQU0sQ0FBQ2lCLHlCQUFYLEVBQXNDO0FBQ2xDLGlCQUFPakIsTUFBTSxDQUFDaUIseUJBQWQ7QUFDSCxTQUZELE1BRU87QUFDSCxjQUFJLENBQUMsS0FBS0MsMEJBQVYsRUFBc0M7QUFDbEMsaUJBQUtBLDBCQUFMLEdBQWtDUixLQUFLLFdBQUksS0FBS2hCLFdBQVQsMkJBQXFDLEtBQUtELE9BQTFDLGtDQUFMLENBQXNGVyxJQUF0RixDQUEyRixVQUFDTyxHQUFEO0FBQUEscUJBQU9BLEdBQUcsQ0FBQ0MsSUFBSixFQUFQO0FBQUEsYUFBM0YsRUFDaENSLElBRGdDLENBQzNCLFVBQUNDLFFBQUQsRUFBWTtBQUNmTCxjQUFBQSxNQUFNLENBQUNpQix5QkFBUCxHQUFtQ1osUUFBbkM7QUFDQSxxQkFBT0EsUUFBUDtBQUNILGFBSmlDLFdBSXpCLFVBQUNRLEdBQUQsRUFBTztBQUNaQyxjQUFBQSxPQUFPLENBQUNDLEdBQVIsMkNBQXNERixHQUF0RDtBQUNILGFBTmlDLENBQWxDO0FBT0g7O0FBQ0QsaUJBQU8sS0FBS0ssMEJBQVo7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQU0sMkJBQXFEO0FBQUE7O0FBQUEsVUFBdkNDLElBQXVDLFFBQXZDQSxJQUF1QztBQUFBLFVBQWhDQyxNQUFnQyxRQUFoQ0EsTUFBZ0M7QUFBQSxVQUF2QkMsR0FBdUIsUUFBdkJBLEdBQXVCO0FBQUEsVUFBakJDLEdBQWlCLFFBQWpCQSxHQUFpQjtBQUFBLFVBQVhDLE1BQVcsUUFBWEEsTUFBVzs7QUFDbkQsK0JBQXFELENBQUMsR0FBR3hDLGlCQUFKLEVBQXVCeUMsZ0JBQXZCLENBQXdDTCxJQUF4QyxDQUFyRDtBQUFBLFVBQWtCTSxZQUFsQixzQkFBUUMsUUFBUjtBQUFBLFVBQWlDQyxLQUFqQyxzQkFBaUNBLEtBQWpDO0FBQUEsVUFBeUNDLE1BQXpDLHNCQUF5Q0EsTUFBekM7O0FBQ0EsK0JBQWtDLENBQUMsR0FBRzdDLGlCQUFKLEVBQXVCeUMsZ0JBQXZCLENBQXdDSixNQUF4QyxDQUFsQztBQUFBLFVBQWtCUyxVQUFsQixzQkFBUUgsUUFBUjs7QUFDQSxVQUFNckMsS0FBSyxHQUFHRCxjQUFjLENBQUNxQyxZQUFELENBQTVCOztBQUNBLFVBQU1LLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBQ0MsSUFBRCxFQUFRO0FBQzNCLFlBQUlULEdBQUosRUFBUyxPQUFPUyxJQUFJLEdBQUcsYUFBZDtBQUNULFlBQU1DLFNBQVMsR0FBRyxDQUFDLEdBQUdwRCxzQkFBSixhQUFvQyxDQUFDLEdBQUdJLHVCQUFKLEVBQTZCaUQsdUJBQTdCLENBQXFELENBQUMsR0FBR3ZELE9BQUosRUFBYXdELFNBQWIsQ0FBdUJILElBQXZCLEVBQTZCUixNQUE3QixDQUFyRCxDQUFwQyxFQUFnSSxPQUFoSSxDQUFsQjtBQUNBLGVBQU8sQ0FBQyxHQUFHN0MsT0FBSixFQUFheUQsV0FBYix1QkFBd0MsS0FBSSxDQUFDMUMsT0FBN0MsU0FBdUR1QyxTQUF2RCxTQUFtRVgsR0FBRyxHQUFHLEVBQUgsR0FBUU8sTUFBOUUsRUFBUDtBQUNILE9BSkQ7O0FBS0EsVUFBTVEsU0FBUyxHQUFHLENBQUMsR0FBR3RELFVBQUosRUFBZ0J1RCxjQUFoQixDQUErQmhELEtBQS9CLENBQWxCO0FBQ0EsVUFBTWlELGlCQUFpQixHQUFHRixTQUFTLEdBQUcsQ0FBQyxHQUFHMUQsT0FBSixFQUFhNkQsYUFBYixDQUEyQmQsWUFBM0IsRUFBeUNJLFVBQXpDLEVBQXFERixLQUFyRCxFQUE0RGEsTUFBL0QsR0FBd0UsRUFBM0c7QUFDQSxhQUFPSixTQUFTLEdBQUdFLGlCQUFpQixJQUFJUixjQUFjLENBQUNRLGlCQUFELENBQXRDLEdBQTREUixjQUFjLENBQUN6QyxLQUFELENBQTFGO0FBQ0g7QUFDRDtBQUNKO0FBQ0E7Ozs7V0FBTSxnQkFBT0EsS0FBUCxFQUFjO0FBQ1osYUFBTyxLQUFLUSxtQkFBTCxDQUF5Qk8sSUFBekIsQ0FBOEIsVUFBQ3FDLENBQUQ7QUFBQSxlQUFLQSxDQUFDLENBQUNDLEdBQUYsQ0FBTXJELEtBQU4sQ0FBTDtBQUFBLE9BQTlCLENBQVA7QUFFSDs7O1dBQ0Qsa0JBQVNBLEtBQVQsRUFBZ0I7QUFDWixhQUFPLEtBQUtNLFdBQUwsQ0FBaUJnRCxTQUFqQixDQUEyQnRELEtBQTNCLEVBQWtDZSxJQUFsQyxDQUF1QyxVQUFDTyxHQUFELEVBQU87QUFDakQsWUFBSSxlQUFlQSxHQUFuQixFQUF3QjtBQUNwQixpQkFBTztBQUNIaUMsWUFBQUEsSUFBSSxFQUFFakMsR0FBRyxDQUFDa0MsU0FEUDtBQUVIQyxZQUFBQSxHQUFHLEVBQUVuQyxHQUFHLENBQUNuQyxPQUZOO0FBR0h1RSxZQUFBQSxXQUFXLEVBQUVwQyxHQUFHLENBQUNxQyxNQUFKLENBQVdDLEdBQVgsQ0FBZSxVQUFDQyxDQUFEO0FBQUEscUJBQU07QUFDMUIvQixnQkFBQUEsSUFBSSxFQUFFK0IsQ0FBQyxDQUFDL0IsSUFEa0I7QUFFMUJnQyxnQkFBQUEsSUFBSSxFQUFFRCxDQUFDLENBQUNFO0FBRmtCLGVBQU47QUFBQSxhQUFmO0FBSFYsV0FBUDtBQVNIOztBQUNELGNBQU16QyxHQUFHLENBQUMwQyxLQUFWO0FBQ0gsT0FiTSxDQUFQO0FBY0g7OztXQUNELGtCQUFTaEUsS0FBVCxFQUFnQjtBQUNaLGFBQU8sS0FBS00sV0FBTCxDQUFpQjJELFFBQWpCLENBQTBCakUsS0FBMUIsQ0FBUDtBQUNIOzs7Ozs7QUFnQkxiLGtCQUFBLEdBQWtCZ0IsVUFBbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcGFnZS1sb2FkZXIuanM/ZTg3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcm91dGVyID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlclwiKTtcbnZhciBfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZVwiKSk7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9wYXJzZVJlbGF0aXZlVXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbnZhciBfcm91dGVMb2FkZXIgPSByZXF1aXJlKFwiLi9yb3V0ZS1sb2FkZXJcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZShyb3V0ZSkge1xuICAgIGlmIChyb3V0ZVswXSAhPT0gJy8nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUm91dGUgbmFtZSBzaG91bGQgc3RhcnQgd2l0aCBhIFwiL1wiLCBnb3QgXCIke3JvdXRlfVwiYCk7XG4gICAgfVxuICAgIGlmIChyb3V0ZSA9PT0gJy8nKSByZXR1cm4gcm91dGU7XG4gICAgcmV0dXJuIHJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG59XG5jbGFzcyBQYWdlTG9hZGVyIHtcbiAgICBnZXRQYWdlTGlzdCgpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkudGhlbigobWFuaWZlc3QpPT5tYW5pZmVzdC5zb3J0ZWRQYWdlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX19ERVZfUEFHRVNfTUFOSUZFU1QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93Ll9fREVWX1BBR0VTX01BTklGRVNULnBhZ2VzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvbWlzZWREZXZQYWdlc01hbmlmZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZWREZXZQYWdlc01hbmlmZXN0ID0gZmV0Y2goYCR7dGhpcy5hc3NldFByZWZpeH0vX25leHQvc3RhdGljL2RldmVsb3BtZW50L19kZXZQYWdlc01hbmlmZXN0Lmpzb25gKS50aGVuKChyZXMpPT5yZXMuanNvbigpXG4gICAgICAgICAgICAgICAgICAgICkudGhlbigobWFuaWZlc3QpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuX19ERVZfUEFHRVNfTUFOSUZFU1QgPSBtYW5pZmVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdC5wYWdlcztcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gZmV0Y2ggZGV2UGFnZXNNYW5pZmVzdGAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlZERldlBhZ2VzTWFuaWZlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWlkZGxld2FyZUxpc3QoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yb3V0ZUxvYWRlcikuZ2V0TWlkZGxld2FyZU1hbmlmZXN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fREVWX01JRERMRVdBUkVfTUFOSUZFU1QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93Ll9fREVWX01JRERMRVdBUkVfTUFOSUZFU1Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm9taXNlZE1pZGRsZXdhcmVNYW5pZmVzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VkTWlkZGxld2FyZU1hbmlmZXN0ID0gZmV0Y2goYCR7dGhpcy5hc3NldFByZWZpeH0vX25leHQvc3RhdGljLyR7dGhpcy5idWlsZElkfS9fZGV2TWlkZGxld2FyZU1hbmlmZXN0Lmpzb25gKS50aGVuKChyZXMpPT5yZXMuanNvbigpXG4gICAgICAgICAgICAgICAgICAgICkudGhlbigobWFuaWZlc3QpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuX19ERVZfTUlERExFV0FSRV9NQU5JRkVTVCA9IG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBfZGV2TWlkZGxld2FyZU1hbmlmZXN0YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VkTWlkZGxld2FyZU1hbmlmZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiB0aGUgcm91dGUgaHJlZiAoZmlsZS1zeXN0ZW0gcGF0aClcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFzUGF0aCB0aGUgVVJMIGFzIHNob3duIGluIGJyb3dzZXIgKHZpcnR1YWwgcGF0aCk7IHVzZWQgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqLyBnZXREYXRhSHJlZih7IGhyZWYgLCBhc1BhdGggLCBzc2cgLCByc2MgLCBsb2NhbGUgIH0pIHtcbiAgICAgICAgY29uc3QgeyBwYXRobmFtZTogaHJlZlBhdGhuYW1lICwgcXVlcnkgLCBzZWFyY2ggIH0gPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoaHJlZik7XG4gICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBub3JtYWxpemVSb3V0ZShocmVmUGF0aG5hbWUpO1xuICAgICAgICBjb25zdCBnZXRIcmVmRm9yU2x1ZyA9IChwYXRoKT0+e1xuICAgICAgICAgICAgaWYgKHJzYykgcmV0dXJuIHBhdGggKyAnP19fZmxpZ2h0X18nO1xuICAgICAgICAgICAgY29uc3QgZGF0YVJvdXRlID0gKDAsIF9nZXRBc3NldFBhdGhGcm9tUm91dGUpLmRlZmF1bHQoKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX3JvdXRlcikuYWRkTG9jYWxlKHBhdGgsIGxvY2FsZSkpLCAnLmpzb24nKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3JvdXRlcikuYWRkQmFzZVBhdGgoYC9fbmV4dC9kYXRhLyR7dGhpcy5idWlsZElkfSR7ZGF0YVJvdXRlfSR7c3NnID8gJycgOiBzZWFyY2h9YCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlzRHluYW1pYyA9ICgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZSk7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRlZFJvdXRlID0gaXNEeW5hbWljID8gKDAsIF9yb3V0ZXIpLmludGVycG9sYXRlQXMoaHJlZlBhdGhuYW1lLCBhc1BhdGhuYW1lLCBxdWVyeSkucmVzdWx0IDogJyc7XG4gICAgICAgIHJldHVybiBpc0R5bmFtaWMgPyBpbnRlcnBvbGF0ZWRSb3V0ZSAmJiBnZXRIcmVmRm9yU2x1ZyhpbnRlcnBvbGF0ZWRSb3V0ZSkgOiBnZXRIcmVmRm9yU2x1Zyhyb3V0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGUgLSB0aGUgcm91dGUgKGZpbGUtc3lzdGVtIHBhdGgpXG4gICAqLyBfaXNTc2cocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZWRTc2dNYW5pZmVzdC50aGVuKChzKT0+cy5oYXMocm91dGUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGxvYWRQYWdlKHJvdXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlTG9hZGVyLmxvYWRSb3V0ZShyb3V0ZSkudGhlbigocmVzKT0+e1xuICAgICAgICAgICAgaWYgKCdjb21wb25lbnQnIGluIHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IHJlcy5jb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIG1vZDogcmVzLmV4cG9ydHMsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVzLm1hcCgobyk9Pih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogby5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG8uY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcmVmZXRjaChyb3V0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5wcmVmZXRjaChyb3V0ZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ1aWxkSWQsIGFzc2V0UHJlZml4KXtcbiAgICAgICAgdGhpcy5yb3V0ZUxvYWRlciA9ICgwLCBfcm91dGVMb2FkZXIpLmNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4KTtcbiAgICAgICAgdGhpcy5idWlsZElkID0gYnVpbGRJZDtcbiAgICAgICAgdGhpcy5hc3NldFByZWZpeCA9IGFzc2V0UHJlZml4O1xuICAgICAgICAvKiogQHR5cGUge1Byb21pc2U8U2V0PHN0cmluZz4+fSAqLyB0aGlzLnByb21pc2VkU3NnTWFuaWZlc3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX19TU0dfTUFOSUZFU1QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdy5fX1NTR19NQU5JRkVTVCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX1NTR19NQU5JRkVTVF9DQiA9ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93Ll9fU1NHX01BTklGRVNUKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQYWdlTG9hZGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfcm91dGVyIiwicmVxdWlyZSIsIl9nZXRBc3NldFBhdGhGcm9tUm91dGUiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2lzRHluYW1pYyIsIl9wYXJzZVJlbGF0aXZlVXJsIiwiX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJfcm91dGVMb2FkZXIiLCJvYmoiLCJfX2VzTW9kdWxlIiwibm9ybWFsaXplUm91dGUiLCJyb3V0ZSIsIkVycm9yIiwicmVwbGFjZSIsIlBhZ2VMb2FkZXIiLCJidWlsZElkIiwiYXNzZXRQcmVmaXgiLCJyb3V0ZUxvYWRlciIsImNyZWF0ZVJvdXRlTG9hZGVyIiwicHJvbWlzZWRTc2dNYW5pZmVzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwid2luZG93IiwiX19TU0dfTUFOSUZFU1QiLCJfX1NTR19NQU5JRkVTVF9DQiIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwibWFuaWZlc3QiLCJzb3J0ZWRQYWdlcyIsIl9fREVWX1BBR0VTX01BTklGRVNUIiwicGFnZXMiLCJwcm9taXNlZERldlBhZ2VzTWFuaWZlc3QiLCJmZXRjaCIsInJlcyIsImpzb24iLCJlcnIiLCJjb25zb2xlIiwibG9nIiwiZ2V0TWlkZGxld2FyZU1hbmlmZXN0IiwiX19ERVZfTUlERExFV0FSRV9NQU5JRkVTVCIsInByb21pc2VkTWlkZGxld2FyZU1hbmlmZXN0IiwiaHJlZiIsImFzUGF0aCIsInNzZyIsInJzYyIsImxvY2FsZSIsInBhcnNlUmVsYXRpdmVVcmwiLCJocmVmUGF0aG5hbWUiLCJwYXRobmFtZSIsInF1ZXJ5Iiwic2VhcmNoIiwiYXNQYXRobmFtZSIsImdldEhyZWZGb3JTbHVnIiwicGF0aCIsImRhdGFSb3V0ZSIsInJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoIiwiYWRkTG9jYWxlIiwiYWRkQmFzZVBhdGgiLCJpc0R5bmFtaWMiLCJpc0R5bmFtaWNSb3V0ZSIsImludGVycG9sYXRlZFJvdXRlIiwiaW50ZXJwb2xhdGVBcyIsInJlc3VsdCIsInMiLCJoYXMiLCJsb2FkUm91dGUiLCJwYWdlIiwiY29tcG9uZW50IiwibW9kIiwic3R5bGVTaGVldHMiLCJzdHlsZXMiLCJtYXAiLCJvIiwidGV4dCIsImNvbnRlbnQiLCJlcnJvciIsInByZWZldGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/page-loader.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\n\nvar _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\n\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n} // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\n\n\nvar MS_MAX_IDLE_DELAY = 3800;\n\nfunction withFuture(key, map, generator) {\n  var entry = map.get(key);\n\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future;\n    }\n\n    return Promise.resolve(entry);\n  }\n\n  var resolver;\n  var prom = new Promise(function (resolve) {\n    resolver = resolve;\n  });\n  map.set(key, entry = {\n    resolve: resolver,\n    future: prom\n  });\n  return generator ? generator() // eslint-disable-next-line no-sequences\n  .then(function (value) {\n    return resolver(value), value;\n  })[\"catch\"](function (err) {\n    map[\"delete\"](key);\n    throw err;\n  }) : prom;\n}\n\nfunction hasPrefetch(link) {\n  try {\n    link = document.createElement('link');\n    return (// detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\nvar canPrefetch = hasPrefetch();\n\nfunction prefetchViaDom(href, as, link) {\n  return new Promise(function (res, rej) {\n    var selector = \"\\n      link[rel=\\\"prefetch\\\"][href^=\\\"\".concat(href, \"\\\"],\\n      link[rel=\\\"preload\\\"][href^=\\\"\").concat(href, \"\\\"],\\n      script[src^=\\\"\").concat(href, \"\\\"]\");\n\n    if (document.querySelector(selector)) {\n      return res();\n    }\n\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = \"prefetch\";\n    link.crossOrigin = undefined;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nvar ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\n\nfunction markAssetError(err) {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\n\nfunction isAssetError(err) {\n  return err && ASSET_LOAD_ERROR in err;\n}\n\nfunction appendScript(src, script) {\n  return new Promise(function (resolve, reject) {\n    script = document.createElement('script'); // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n\n    script.onload = resolve;\n\n    script.onerror = function () {\n      return reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n    }; // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n\n\n    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n\n    script.src = src;\n    document.body.appendChild(script);\n  });\n} // We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\n\n\nvar devBuildPromise; // Resolve a promise that times out after given amount of milliseconds.\n\nfunction resolvePromiseWithTimeout(p, ms, err) {\n  return new Promise(function (resolve, reject) {\n    var cancelled = false;\n    p.then(function (r) {\n      // Resolved, cancel the timeout\n      cancelled = true;\n      resolve(r);\n    })[\"catch\"](reject); // We wrap these checks separately for better dead-code elimination in\n    // production bundles.\n\n    if (true) {\n      (devBuildPromise || Promise.resolve()).then(function () {\n        (0, _requestIdleCallback).requestIdleCallback(function () {\n          return setTimeout(function () {\n            if (!cancelled) {\n              reject(err);\n            }\n          }, ms);\n        });\n      });\n    }\n\n    if (false) {}\n  });\n}\n\nfunction getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST);\n  }\n\n  var onBuildManifest = new Promise(function (resolve) {\n    // Mandatory because this is not concurrent safe:\n    var cb = self.__BUILD_MANIFEST_CB;\n\n    self.__BUILD_MANIFEST_CB = function () {\n      resolve(self.__BUILD_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\n\nfunction getMiddlewareManifest() {\n  if (self.__MIDDLEWARE_MANIFEST) {\n    return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n  }\n\n  var onMiddlewareManifest = new Promise(function (resolve) {\n    var cb = self.__MIDDLEWARE_MANIFEST_CB;\n\n    self.__MIDDLEWARE_MANIFEST_CB = function () {\n      resolve(self.__MIDDLEWARE_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\n\nfunction getFilesForRoute(assetPrefix, route) {\n  if (true) {\n    return Promise.resolve({\n      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute)[\"default\"](route, '.js'))],\n      // Styles are handled by `style-loader` in development:\n      css: []\n    });\n  }\n\n  return getClientBuildManifest().then(function (manifest) {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n    }\n\n    var allFiles = manifest[route].map(function (entry) {\n      return assetPrefix + '/_next/' + encodeURI(entry);\n    });\n    return {\n      scripts: allFiles.filter(function (v) {\n        return v.endsWith('.js');\n      }),\n      css: allFiles.filter(function (v) {\n        return v.endsWith('.css');\n      })\n    };\n  });\n}\n\nfunction createRouteLoader(assetPrefix) {\n  var entrypoints = new Map();\n  var loadedScripts = new Map();\n  var styleSheets = new Map();\n  var routes = new Map();\n\n  function maybeExecuteScript(src) {\n    // With HMR we might need to \"reload\" scripts when they are\n    // disposed and readded. Executing scripts twice has no functional\n    // differences\n    if (false) { var prom; } else {\n      return appendScript(src);\n    }\n  }\n\n  function fetchStyleSheet(href) {\n    var prom = styleSheets.get(href);\n\n    if (prom) {\n      return prom;\n    }\n\n    styleSheets.set(href, prom = fetch(href).then(function (res) {\n      if (!res.ok) {\n        throw new Error(\"Failed to load stylesheet: \".concat(href));\n      }\n\n      return res.text().then(function (text) {\n        return {\n          href: href,\n          content: text\n        };\n      });\n    })[\"catch\"](function (err) {\n      throw markAssetError(err);\n    }));\n    return prom;\n  }\n\n  return {\n    whenEntrypoint: function whenEntrypoint(route) {\n      return withFuture(route, entrypoints);\n    },\n    onEntrypoint: function onEntrypoint(route, execute) {\n      (execute ? Promise.resolve().then(function () {\n        return execute();\n      }).then(function (exports) {\n        return {\n          component: exports && exports[\"default\"] || exports,\n          exports: exports\n        };\n      }, function (err) {\n        return {\n          error: err\n        };\n      }) : Promise.resolve(undefined)).then(function (input) {\n        var old = entrypoints.get(route);\n\n        if (old && 'resolve' in old) {\n          if (input) {\n            entrypoints.set(route, input);\n            old.resolve(input);\n          }\n        } else {\n          if (input) {\n            entrypoints.set(route, input);\n          } else {\n            entrypoints[\"delete\"](route);\n          } // when this entrypoint has been resolved before\n          // the route is outdated and we want to invalidate\n          // this cache entry\n\n\n          routes[\"delete\"](route);\n        }\n      });\n    },\n    loadRoute: function loadRoute(route, prefetch) {\n      var _this = this;\n\n      return withFuture(route, routes, function () {\n        var routeFilesPromise = getFilesForRoute(assetPrefix, route).then(function (_ref) {\n          var scripts = _ref.scripts,\n              css = _ref.css;\n          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);\n        }).then(function (res) {\n          return _this.whenEntrypoint(route).then(function (entrypoint) {\n            return {\n              entrypoint: entrypoint,\n              styles: res[1]\n            };\n          });\n        });\n\n        if (true) {\n          devBuildPromise = new Promise(function (resolve) {\n            if (routeFilesPromise) {\n              return routeFilesPromise[\"finally\"](function () {\n                resolve();\n              });\n            }\n          });\n        }\n\n        return resolvePromiseWithTimeout(routeFilesPromise, MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then(function (_ref2) {\n          var entrypoint = _ref2.entrypoint,\n              styles = _ref2.styles;\n          var res = Object.assign({\n            styles: styles\n          }, entrypoint);\n          return 'error' in entrypoint ? entrypoint : res;\n        })[\"catch\"](function (err) {\n          if (prefetch) {\n            // we don't want to cache errors during prefetch\n            throw err;\n          }\n\n          return {\n            error: err\n          };\n        });\n      });\n    },\n    prefetch: function prefetch(route) {\n      var _this2 = this;\n\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      var cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n\n      return getFilesForRoute(assetPrefix, route).then(function (output) {\n        return Promise.all(canPrefetch ? output.scripts.map(function (script) {\n          return prefetchViaDom(script, 'script');\n        }) : []);\n      }).then(function () {\n        (0, _requestIdleCallback).requestIdleCallback(function () {\n          return _this2.loadRoute(route, true)[\"catch\"](function () {});\n        });\n      })[\"catch\"]( // swallow prefetch errors\n      function () {});\n    }\n  };\n}\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUNiQSw4Q0FBNkM7QUFDekNHLEVBQUFBLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxzQkFBQSxHQUF5QkUsY0FBekI7QUFDQUYsb0JBQUEsR0FBdUJHLFlBQXZCO0FBQ0FILDhCQUFBLEdBQWlDSSxzQkFBakM7QUFDQUosNkJBQUEsR0FBZ0NLLHFCQUFoQztBQUNBTCx5QkFBQSxHQUE0Qk0saUJBQTVCOztBQUNBLElBQUlDLHNCQUFzQixHQUFHQyxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywySUFBRCxDQUFSLENBQW5EOztBQUNBLElBQUlDLG9CQUFvQixHQUFHRCxtQkFBTyxDQUFDLHlGQUFELENBQWxDOztBQUNBLFNBQVNELHNCQUFULENBQWdDRyxHQUFoQyxFQUFxQztBQUNqQyxTQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBWCxHQUF3QkQsR0FBeEIsR0FBOEI7QUFDakMsZUFBU0E7QUFEd0IsR0FBckM7QUFHSCxFQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFNRSxpQkFBaUIsR0FBRyxJQUExQjs7QUFDQSxTQUFTQyxVQUFULENBQW9CQyxHQUFwQixFQUF5QkMsR0FBekIsRUFBOEJDLFNBQTlCLEVBQXlDO0FBQ3JDLE1BQUlDLEtBQUssR0FBR0YsR0FBRyxDQUFDRyxHQUFKLENBQVFKLEdBQVIsQ0FBWjs7QUFDQSxNQUFJRyxLQUFKLEVBQVc7QUFDUCxRQUFJLFlBQVlBLEtBQWhCLEVBQXVCO0FBQ25CLGFBQU9BLEtBQUssQ0FBQ0UsTUFBYjtBQUNIOztBQUNELFdBQU9DLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQkosS0FBaEIsQ0FBUDtBQUNIOztBQUNELE1BQUlLLFFBQUo7QUFDQSxNQUFNQyxJQUFJLEdBQUcsSUFBSUgsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVztBQUNoQ0MsSUFBQUEsUUFBUSxHQUFH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QUFuQixFQUErQjtBQUMzQjtBQUNBLFlBQUlGLEVBQUUsQ0FBQ0csUUFBSCxJQUFlLEtBQUtDLElBQUwsQ0FBVUosRUFBRSxDQUFDSyxhQUFiLENBQW5CLEVBQWdELE9BQU9yRyxPQUFPLENBQUNDLE9BQVIsRUFBUDtBQUNuRDs7QUFDRCxhQUFPeUQsZ0JBQWdCLENBQUNDLFdBQUQsRUFBY0MsS0FBZCxDQUFoQixDQUFxQ3ZELElBQXJDLENBQTBDLFVBQUNpRyxNQUFEO0FBQUEsZUFBVXRHLE9BQU8sQ0FBQzJGLEdBQVIsQ0FBWTFFLFdBQVcsR0FBR3FGLE1BQU0sQ0FBQ3pDLE9BQVAsQ0FBZWxFLEdBQWYsQ0FBbUIsVUFBQzJDLE1BQUQ7QUFBQSxpQkFBVXBCLGNBQWMsQ0FBQ29CLE1BQUQsRUFBUyxRQUFULENBQXhCO0FBQUEsU0FBbkIsQ0FBSCxHQUMxRSxFQURtRCxDQUFWO0FBQUEsT0FBMUMsRUFFTGpDLElBRkssQ0FFQSxZQUFJO0FBQ1AsU0FBQyxHQUFHaEIsb0JBQUosRUFBMEIyRCxtQkFBMUIsQ0FBOEM7QUFBQSxpQkFBSSxNQUFJLENBQUN3QyxTQUFMLENBQWU1QixLQUFmLEVBQXNCLElBQXRCLFdBQWtDLFlBQUksQ0FDbkYsQ0FENkMsQ0FBSjtBQUFBLFNBQTlDO0FBR0gsT0FOTSxZQU1FO0FBQ1Qsa0JBQUksQ0FDSCxDQVJNLENBQVA7QUFTSDtBQXpGRSxHQUFQO0FBMkZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLWxvYWRlci5qcz9lYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXJrQXNzZXRFcnJvciA9IG1hcmtBc3NldEVycm9yO1xuZXhwb3J0cy5pc0Fzc2V0RXJyb3IgPSBpc0Fzc2V0RXJyb3I7XG5leHBvcnRzLmdldENsaWVudEJ1aWxkTWFuaWZlc3QgPSBnZXRDbGllbnRCdWlsZE1hbmlmZXN0O1xuZXhwb3J0cy5nZXRNaWRkbGV3YXJlTWFuaWZlc3QgPSBnZXRNaWRkbGV3YXJlTWFuaWZlc3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRlTG9hZGVyID0gY3JlYXRlUm91dGVMb2FkZXI7XG52YXIgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMDtcbmZ1bmN0aW9uIHdpdGhGdXR1cmUoa2V5LCBtYXAsIGdlbmVyYXRvcikge1xuICAgIGxldCBlbnRyeSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZnV0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZXI7XG4gICAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbWFwLnNldChrZXksIGVudHJ5ID0ge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlcixcbiAgICAgICAgZnV0dXJlOiBwcm9tXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvciA/IGdlbmVyYXRvcigpLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgIC50aGVuKCh2YWx1ZSk9PihyZXNvbHZlcih2YWx1ZSksIHZhbHVlKVxuICAgICkuY2F0Y2goKGVycik9PntcbiAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSkgOiBwcm9tO1xufVxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaykge1xuICAgIHRyeSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIHJldHVybigvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB8fCBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGNhblByZWZldGNoID0gaGFzUHJlZmV0Y2goKTtcbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKGhyZWYsIGFzLCBsaW5rKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaik9PntcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBgXG4gICAgICBsaW5rW3JlbD1cInByZWZldGNoXCJdW2hyZWZePVwiJHtocmVmfVwiXSxcbiAgICAgIGxpbmtbcmVsPVwicHJlbG9hZFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXG4gICAgICBzY3JpcHRbc3JjXj1cIiR7aHJlZn1cIl1gO1xuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsOlxuICAgICAgICBpZiAoYXMpIGxpbmsuYXMgPSBhcztcbiAgICAgICAgbGluay5yZWwgPSBgcHJlZmV0Y2hgO1xuICAgICAgICBsaW5rLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcbiAgICAgICAgbGluay5vbmxvYWQgPSByZXM7XG4gICAgICAgIGxpbmsub25lcnJvciA9IHJlajtcbiAgICAgICAgLy8gYGhyZWZgIHNob3VsZCBhbHdheXMgYmUgbGFzdDpcbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9KTtcbn1cbmNvbnN0IEFTU0VUX0xPQURfRVJST1IgPSBTeW1ib2woJ0FTU0VUX0xPQURfRVJST1InKTtcbmZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycikge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc0Fzc2V0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyciAmJiBBU1NFVF9MT0FEX0VSUk9SIGluIGVycjtcbn1cbmZ1bmN0aW9uIGFwcGVuZFNjcmlwdChzcmMsIHNjcmlwdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbC5cbiAgICAgICAgLy8gMS4gU2V0dXAgc3VjY2Vzcy9mYWlsdXJlIGhvb2tzIGluIGNhc2UgdGhlIGJyb3dzZXIgc3luY2hyb25vdXNseVxuICAgICAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gKCk9PnJlamVjdChtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNjcmlwdDogJHtzcmN9YCkpKVxuICAgICAgICA7XG4gICAgICAgIC8vIDIuIENvbmZpZ3VyZSB0aGUgY3Jvc3Mtb3JpZ2luIGF0dHJpYnV0ZSBiZWZvcmUgc2V0dGluZyBgc3JjYCBpbiBjYXNlIHRoZVxuICAgICAgICAvLyAgICBicm93c2VyIGJlZ2lucyB0byBmZXRjaC5cbiAgICAgICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcbiAgICAgICAgLy8gMy4gRmluYWxseSwgc2V0IHRoZSBzb3VyY2UgYW5kIGluamVjdCBpbnRvIHRoZSBET00gaW4gY2FzZSB0aGUgY2hpbGRcbiAgICAgICAgLy8gICAgbXVzdCBiZSBhcHBlbmRlZCBmb3IgZmV0Y2hpbmcgdG8gc3RhcnQuXG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KTtcbn1cbi8vIFdlIHdhaXQgZm9yIHBhZ2VzIHRvIGJlIGJ1aWx0IGluIGRldiBiZWZvcmUgd2Ugc3RhcnQgdGhlIHJvdXRlIHRyYW5zaXRpb25cbi8vIHRpbWVvdXQgdG8gcHJldmVudCBhbiB1bi1uZWNlc3NhcnkgaGFyZCBuYXZpZ2F0aW9uIGluIGRldmVsb3BtZW50LlxubGV0IGRldkJ1aWxkUHJvbWlzZTtcbi8vIFJlc29sdmUgYSBwcm9taXNlIHRoYXQgdGltZXMgb3V0IGFmdGVyIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHMuXG5mdW5jdGlvbiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KHAsIG1zLCBlcnIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBwLnRoZW4oKHIpPT57XG4gICAgICAgICAgICAvLyBSZXNvbHZlZCwgY2FuY2VsIHRoZSB0aW1lb3V0XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgLy8gV2Ugd3JhcCB0aGVzZSBjaGVja3Mgc2VwYXJhdGVseSBmb3IgYmV0dGVyIGRlYWQtY29kZSBlbGltaW5hdGlvbiBpblxuICAgICAgICAvLyBwcm9kdWN0aW9uIGJ1bmRsZXMuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgKGRldkJ1aWxkUHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgbXMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG1zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpIHtcbiAgICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtcbiAgICB9XG4gICAgY29uc3Qgb25CdWlsZE1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIC8vIE1hbmRhdG9yeSBiZWNhdXNlIHRoaXMgaXMgbm90IGNvbmN1cnJlbnQgc2FmZTpcbiAgICAgICAgY29uc3QgY2IgPSBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0I7XG4gICAgICAgIHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpPT57XG4gICAgICAgICAgICByZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVCk7XG4gICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KG9uQnVpbGRNYW5pZmVzdCwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IGJ1aWxkIG1hbmlmZXN0JykpKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVNYW5pZmVzdCgpIHtcbiAgICBpZiAoc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fTUlERExFV0FSRV9NQU5JRkVTVCk7XG4gICAgfVxuICAgIGNvbnN0IG9uTWlkZGxld2FyZU1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIGNvbnN0IGNiID0gc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1RfQ0I7XG4gICAgICAgIHNlbGYuX19NSURETEVXQVJFX01BTklGRVNUX0NCID0gKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1QpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChvbk1pZGRsZXdhcmVNYW5pZmVzdCwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IG1pZGRsZXdhcmUgbWFuaWZlc3QnKSkpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBzY3JpcHRzOiBbXG4gICAgICAgICAgICAgICAgYXNzZXRQcmVmaXggKyAnL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMnICsgZW5jb2RlVVJJKCgwLCBfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKS5kZWZhdWx0KHJvdXRlLCAnLmpzJykpLCBcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICAgICAgICBjc3M6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKChlbnRyeSk9PmFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KT0+di5lbmRzV2l0aCgnLmpzJylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodik9PnYuZW5kc1dpdGgoJy5jc3MnKVxuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlUm91dGVMb2FkZXIoYXNzZXRQcmVmaXgpIHtcbiAgICBjb25zdCBlbnRyeXBvaW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBsb2FkZWRTY3JpcHRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjKSB7XG4gICAgICAgIC8vIFdpdGggSE1SIHdlIG1pZ2h0IG5lZWQgdG8gXCJyZWxvYWRcIiBzY3JpcHRzIHdoZW4gdGhleSBhcmVcbiAgICAgICAgLy8gZGlzcG9zZWQgYW5kIHJlYWRkZWQuIEV4ZWN1dGluZyBzY3JpcHRzIHR3aWNlIGhhcyBubyBmdW5jdGlvbmFsXG4gICAgICAgIC8vIGRpZmZlcmVuY2VzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgbGV0IHByb20gPSBsb2FkZWRTY3JpcHRzLmdldChzcmMpO1xuICAgICAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7c3JjfVwiXWApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLCBwcm9tID0gYXBwZW5kU2NyaXB0KHNyYykpO1xuICAgICAgICAgICAgcmV0dXJuIHByb207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kU2NyaXB0KHNyYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTdHlsZVNoZWV0KGhyZWYpIHtcbiAgICAgICAgbGV0IHByb20gPSBzdHlsZVNoZWV0cy5nZXQoaHJlZik7XG4gICAgICAgIGlmIChwcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVNoZWV0cy5zZXQoaHJlZiwgcHJvbSA9IGZldGNoKGhyZWYpLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdHlsZXNoZWV0OiAke2hyZWZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKCh0ZXh0KT0+KHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGV4dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2hlbkVudHJ5cG9pbnQgKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudHJ5cG9pbnQgKHJvdXRlLCBleGVjdXRlKSB7XG4gICAgICAgICAgICAoZXhlY3V0ZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmV4ZWN1dGUoKVxuICAgICAgICAgICAgKS50aGVuKChleHBvcnRzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBleHBvcnRzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICwgKGVycik9Pih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKS50aGVuKChpbnB1dCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpO1xuICAgICAgICAgICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnJlc29sdmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGVudHJ5cG9pbnQgaGFzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByb3V0ZSBpcyBvdXRkYXRlZCBhbmQgd2Ugd2FudCB0byBpbnZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgcm91dGVzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRSb3V0ZSAocm91dGUsIHByZWZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgcm91dGVzLCAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlRmlsZXNQcm9taXNlID0gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKHsgc2NyaXB0cyAsIGNzcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSkgPyBbXSA6IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKG1heWJlRXhlY3V0ZVNjcmlwdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSwgXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLnRoZW4oKGVudHJ5cG9pbnQpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiByZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldkJ1aWxkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlRmlsZXNQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlRmlsZXNQcm9taXNlLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQocm91dGVGaWxlc1Byb21pc2UsIE1TX01BWF9JRExFX0RFTEFZLCBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYFJvdXRlIGRpZCBub3QgY29tcGxldGUgbG9hZGluZzogJHtyb3V0ZX1gKSkpLnRoZW4oKHsgZW50cnlwb2ludCAsIHN0eWxlcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICB9LCBlbnRyeXBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXM7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIGVycm9ycyBkdXJpbmcgcHJlZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZldGNoIChyb3V0ZSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgICAgICAgbGV0IGNuO1xuICAgICAgICAgICAgaWYgKGNuID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKG91dHB1dCk9PlByb21pc2UuYWxsKGNhblByZWZldGNoID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpPT5wcmVmZXRjaFZpYURvbShzY3JpcHQsICdzY3JpcHQnKVxuICAgICAgICAgICAgICAgICkgOiBbXSlcbiAgICAgICAgICAgICkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+dGhpcy5sb2FkUm91dGUocm91dGUsIHRydWUpLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgICAoKT0+e1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1sb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWFya0Fzc2V0RXJyb3IiLCJpc0Fzc2V0RXJyb3IiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiZ2V0TWlkZGxld2FyZU1hbmlmZXN0IiwiY3JlYXRlUm91dGVMb2FkZXIiLCJfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfcmVxdWVzdElkbGVDYWxsYmFjayIsIm9iaiIsIl9fZXNNb2R1bGUiLCJNU19NQVhfSURMRV9ERUxBWSIsIndpdGhGdXR1cmUiLCJrZXkiLCJtYXAiLCJnZW5lcmF0b3IiLCJlbnRyeSIsImdldCIsImZ1dHVyZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzb2x2ZXIiLCJwcm9tIiwic2V0IiwidGhlbiIsImVyciIsImhhc1ByZWZldGNoIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpbmRvdyIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiZSIsImNhblByZWZldGNoIiwicHJlZmV0Y2hWaWFEb20iLCJocmVmIiwiYXMiLCJyZXMiLCJyZWoiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWwiLCJjcm9zc09yaWdpbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ1JPU1NfT1JJR0lOIiwib25sb2FkIiwib25lcnJvciIsImhlYWQiLCJhcHBlbmRDaGlsZCIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJhcHBlbmRTY3JpcHQiLCJzcmMiLCJzY3JpcHQiLCJyZWplY3QiLCJFcnJvciIsImJvZHkiLCJkZXZCdWlsZFByb21pc2UiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0IiwicCIsIm1zIiwiY2FuY2VsbGVkIiwiciIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZXRUaW1lb3V0Iiwic2VsZiIsIl9fQlVJTERfTUFOSUZFU1QiLCJvbkJ1aWxkTWFuaWZlc3QiLCJjYiIsIl9fQlVJTERfTUFOSUZFU1RfQ0IiLCJfX01JRERMRVdBUkVfTUFOSUZFU1QiLCJvbk1pZGRsZXdhcmVNYW5pZmVzdCIsIl9fTUlERExFV0FSRV9NQU5JRkVTVF9DQiIsImdldEZpbGVzRm9yUm91dGUiLCJhc3NldFByZWZpeCIsInJvdXRlIiwic2NyaXB0cyIsImVuY29kZVVSSSIsImNzcyIsIm1hbmlmZXN0IiwiYWxsRmlsZXMiLCJmaWx0ZXIiLCJ2IiwiZW5kc1dpdGgiLCJlbnRyeXBvaW50cyIsIk1hcCIsImxvYWRlZFNjcmlwdHMiLCJzdHlsZVNoZWV0cyIsInJvdXRlcyIsIm1heWJlRXhlY3V0ZVNjcmlwdCIsImZldGNoU3R5bGVTaGVldCIsImZldGNoIiwib2siLCJ0ZXh0IiwiY29udGVudCIsIndoZW5FbnRyeXBvaW50Iiwib25FbnRyeXBvaW50IiwiZXhlY3V0ZSIsImNvbXBvbmVudCIsImVycm9yIiwidW5kZWZpbmVkIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJwcmVmZXRjaCIsInJvdXRlRmlsZXNQcm9taXNlIiwiYWxsIiwiaGFzIiwiZW50cnlwb2ludCIsInN0eWxlcyIsImFzc2lnbiIsImNuIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNhdmVEYXRhIiwidGVzdCIsImVmZmVjdGl2ZVR5cGUiLCJvdXRwdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/regenerator */ \"./node_modules/next/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty */ \"./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js\");\n\nvar _asyncToGenerator = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator */ \"./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck */ \"./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/createClass */ \"./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ \"./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports[\"default\"] = void 0;\n\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\n\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nvar _isError = _interopRequireDefault(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\n\nvar _denormalizePagePath = __webpack_require__(/*! ../../../server/denormalize-page-path */ \"./node_modules/next/dist/server/denormalize-page-path.js\");\n\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\n\nvar _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\n\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\n\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\n\nvar _getMiddlewareRegex = __webpack_require__(/*! ./utils/get-middleware-regex */ \"./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar detectDomainLocale;\n\nif (false) {}\n\nvar basePath =  false || '';\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\n\nfunction addPathPrefix(path, prefix) {\n  if (!path.startsWith('/') || !prefix) {\n    return path;\n  }\n\n  var pathname = pathNoQueryHash(path);\n  return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(\"\".concat(prefix).concat(pathname)) + path.substr(pathname.length);\n}\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (false) { var detectedDomain; } else {\n    return false;\n  }\n}\n\nfunction addLocale(path, locale, defaultLocale) {\n  if (false) { var localeLower, pathLower, pathname; }\n\n  return path;\n}\n\nfunction delLocale(path, locale) {\n  if (false) { var localeLower, pathLower, pathname; }\n\n  return path;\n}\n\nfunction pathNoQueryHash(path) {\n  var queryIndex = path.indexOf('?');\n  var hashIndex = path.indexOf('#');\n\n  if (queryIndex > -1 || hashIndex > -1) {\n    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n  }\n\n  return path;\n}\n\nfunction hasBasePath(path) {\n  path = pathNoQueryHash(path);\n  return path === basePath || path.startsWith(basePath + '/');\n}\n\nfunction addBasePath(path) {\n  // we only add the basepath on relative urls\n  return addPathPrefix(path, basePath);\n}\n\nfunction delBasePath(path) {\n  path = path.slice(basePath.length);\n  if (!path.startsWith('/')) path = \"/\".concat(path);\n  return path;\n}\n\nfunction isLocalURL(url) {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n\n  try {\n    // absolute urls can be local if they are on the same origin\n    var locationOrigin = (0, _utils).getLocationOrigin();\n    var resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction interpolateAs(route, asPathname, query) {\n  var interpolatedRoute = '';\n  var dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n  var dynamicGroups = dynamicRegex.groups;\n  var dynamicMatches = // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  var params = Object.keys(dynamicGroups);\n\n  if (!params.every(function (param) {\n    var value = dynamicMatches[param] || '';\n    var _dynamicGroups$param = dynamicGroups[param],\n        repeat = _dynamicGroups$param.repeat,\n        optional = _dynamicGroups$param.optional; // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n\n    var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n\n    if (optional) {\n      replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n    }\n\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    function (segment) {\n      return encodeURIComponent(segment);\n    }).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = '' // did not satisfy all requirements\n    ; // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params: params,\n    result: interpolatedRoute\n  };\n}\n\nfunction omitParmsFromQuery(query, params) {\n  var filteredQuery = {};\n  Object.keys(query).forEach(function (key) {\n    if (!params.includes(key)) {\n      filteredQuery[key] = query[key];\n    }\n  });\n  return filteredQuery;\n}\n\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  var base;\n  var urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href); // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n\n  var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  var urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n  var urlParts = urlAsStringNoProto.split('?');\n\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n    var normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n  } // Return because it cannot be routed by the Next.js router\n\n\n  if (!isLocalURL(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n\n  try {\n    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n');\n  }\n\n  try {\n    var finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n    var interpolatedAs = '';\n\n    if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      var query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n\n      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),\n          result = _interpolateAs.result,\n          params = _interpolateAs.params;\n\n      if (result) {\n        interpolatedAs = (0, _utils).formatWithValidation({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omitParmsFromQuery(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n\n\n    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_1) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils).getLocationOrigin();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _resolveHref = resolveHref(router, url, true),\n      _resolveHref2 = _slicedToArray(_resolveHref, 2),\n      resolvedHref = _resolveHref2[0],\n      resolvedAs = _resolveHref2[1];\n\n  var origin = (0, _utils).getLocationOrigin();\n  var hrefHadOrigin = resolvedHref.startsWith(origin);\n  var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n  var preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\n\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\n\nfunction fetchRetry(url, attempts, opts) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wont send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin'\n  }).then(function (res) {\n    if (!res.ok) {\n      if (attempts > 1 && res.status >= 500) {\n        return fetchRetry(url, attempts - 1, opts);\n      }\n\n      if (res.status === 404) {\n        return res.json().then(function (data) {\n          if (data.notFound) {\n            return {\n              notFound: SSG_DATA_NOT_FOUND\n            };\n          }\n\n          throw new Error(\"Failed to load static props\");\n        });\n      }\n\n      throw new Error(\"Failed to load static props\");\n    }\n\n    return opts.text ? res.text() : res.json();\n  });\n}\n\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n    text: text\n  })[\"catch\"](function (err) {\n    // We should only trigger a server-side transition if this was caused\n    // on a client-side transition. Otherwise, we'd get into an infinite\n    // loop.\n    if (!isServerRender) {\n      (0, _routeLoader).markAssetError(err);\n    }\n\n    throw err;\n  }).then(function (data) {\n    if (!persistCache || true) {\n      delete inflightCache[cacheKey];\n    }\n\n    return data;\n  })[\"catch\"](function (err) {\n    delete inflightCache[cacheKey];\n    throw err;\n  });\n}\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname, query, as, _ref) {\n    var _this = this;\n\n    var initialProps = _ref.initialProps,\n        pageLoader = _ref.pageLoader,\n        App = _ref.App,\n        wrapApp = _ref.wrapApp,\n        Component = _ref.Component,\n        err = _ref.err,\n        subscription = _ref.subscription,\n        isFallback = _ref.isFallback,\n        locale = _ref.locale,\n        locales = _ref.locales,\n        defaultLocale = _ref.defaultLocale,\n        domainLocales = _ref.domainLocales,\n        isPreview = _ref.isPreview;\n\n    _classCallCheck(this, Router);\n\n    // Static Data Cache\n    this.sdc = {}; // In-flight Server Data Requests, for deduping\n\n    this.sdr = {}; // In-flight middleware preflight requests\n\n    this.sde = {};\n    this._idx = 0;\n\n    this.onPopState = function (e) {\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname = _this.pathname,\n            _query = _this.query;\n\n        _this.changeState('replaceState', (0, _utils).formatWithValidation({\n          pathname: addBasePath(_pathname),\n          query: _query\n        }), (0, _utils).getURL());\n\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          idx = state.idx;\n\n      if (false) { var v; }\n\n      _this._idx = idx;\n\n      var _parseRelativeUrl2 = (0, _parseRelativeUrl).parseRelativeUrl(url),\n          pathname = _parseRelativeUrl2.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this._bps && !_this._bps(state)) {\n        return;\n      }\n\n      _this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this._shallow,\n        locale: options.locale || _this.defaultLocale\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    this.route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== '/_error') {\n      var ref;\n      this.components[this.route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP,\n        __N_RSC: !!((ref = Component) === null || ref === void 0 ? void 0 : ref.__next_rsc__)\n      };\n    }\n\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    }; // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    this.pathname = pathname;\n    this.query = query; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.asPath = autoExportDynamic ? pathname : as;\n    this.basePath = basePath;\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isFallback = isFallback;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n    this.isPreview = !!isPreview;\n    this.isLocaleDomain = false;\n\n    if (false) {}\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (as.substr(0, 2) !== '//') {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        options._shouldResolveHref = as !== pathname;\n        this.changeState('replaceState', (0, _utils).formatWithValidation({\n          pathname: addBasePath(pathname),\n          query: query\n        }), (0, _utils).getURL(), options);\n      }\n\n      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (false) {}\n    }\n  }\n\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (false) {}\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change('pushState', url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change('replaceState', url, as, options);\n    }\n  }, {\n    key: \"change\",\n    value: function () {\n      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options, forcedScroll) {\n        var shouldResolveHref, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, _options$shallow, shallow, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, rewritesResult, effect, route, _parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, ref1, routeInfo, _routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, isValidShallowRoute, _scroll, shouldScroll, resetScroll;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (isLocalURL(url)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                window.location.href = url;\n                return _context.abrupt(\"return\", false);\n\n              case 3:\n                shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as); // for static pages with query params in the URL we delay\n                // marking the router ready until after the query is updated\n\n                if (options._h) {\n                  this.isReady = true;\n                }\n\n                prevLocale = this.locale;\n\n                if (true) {\n                  _context.next = 18;\n                  break;\n                }\n\n                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;\n\n                if (typeof options.locale === 'undefined') {\n                  options.locale = this.locale;\n                }\n\n                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n                localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n\n                if (localePathResult.detectedLocale) {\n                  this.locale = localePathResult.detectedLocale;\n                  parsedAs.pathname = addBasePath(parsedAs.pathname);\n                  as = (0, _utils).formatWithValidation(parsedAs);\n                  url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n                }\n\n                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale); // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                if (!didNavigate) {\n                  _context.next = 18;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 18:\n                if (!options._h) {\n                  this.isSsr = false;\n                } // marking route changes as a navigation start entry\n\n\n                if (_utils.ST) {\n                  performance.mark('routeChange');\n                }\n\n                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow;\n                routeProps = {\n                  shallow: shallow\n                };\n\n                if (this._inFlightRoute) {\n                  this.abortComponentLoad(this._inFlightRoute, routeProps);\n                }\n\n                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n                this._inFlightRoute = as;\n                localeChange = prevLocale !== this.locale; // If the url change is only related to a hash change\n                // We should not proceed. We should only change the state.\n                // WARNING: `_h` is an internal option for handing Next.js client-side\n                // hydration. Your app should _never_ use this property. It may change at\n                // any time without notice.\n\n                if (!(!options._h && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                this.asPath = cleanedAs;\n                Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n                this.changeState(method, url, as, options);\n                this.scrollToHash(cleanedAs);\n                this.notify(this.components[this.route], null);\n                Router.events.emit('hashChangeComplete', as, routeProps);\n                return _context.abrupt(\"return\", true);\n\n              case 35:\n                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                pathname = parsed.pathname, query = parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages\n                // get their query parameters to allow ensuring they can be parsed properly\n                // when rewritten to\n\n                _context.prev = 37;\n                _context.next = 40;\n                return Promise.all([this.pageLoader.getPageList(), (0, _routeLoader).getClientBuildManifest(), this.pageLoader.getMiddlewareList()]);\n\n              case 40:\n                _yield$Promise$all = _context.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                pages = _yield$Promise$all2[0];\n                rewrites = _yield$Promise$all2[1].__rewrites;\n                _context.next = 50;\n                break;\n\n              case 46:\n                _context.prev = 46;\n                _context.t0 = _context[\"catch\"](37);\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                window.location.href = as;\n                return _context.abrupt(\"return\", false);\n\n              case 50:\n                // If asked to change the current URL we should reload the current page\n                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                // We also need to set the method = replaceState always\n                // as this should not go into the history (That's how browsers work)\n                // We should compare the new asPath to the current asPath, not the url\n                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                  method = 'replaceState';\n                } // we need to resolve the as value using rewrites for dynamic SSG\n                // pages to allow building the data URL correctly\n\n\n                resolvedAs = as; // url and as should always be prefixed with basePath by this\n                // point by either next/link or router.push/replace so strip the\n                // basePath from the pathname to match the pages dir 1-to-1\n\n                pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n\n                if (shouldResolveHref && pathname !== '/_error') {\n                  options._shouldResolveHref = true;\n\n                  if (false) {} else {\n                    parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n                    if (parsed.pathname !== pathname) {\n                      pathname = parsed.pathname;\n                      parsed.pathname = addBasePath(pathname);\n                      url = (0, _utils).formatWithValidation(parsed);\n                    }\n                  }\n                }\n\n                if (isLocalURL(as)) {\n                  _context.next = 59;\n                  break;\n                }\n\n                if (false) {}\n\n                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n              case 57:\n                window.location.href = as;\n                return _context.abrupt(\"return\", false);\n\n              case 59:\n                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n                _context.next = 62;\n                return this._preflightRequest({\n                  as: as,\n                  cache: false,\n                  pages: pages,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 62:\n                effect = _context.sent;\n\n                if (!(effect.type === 'rewrite')) {\n                  _context.next = 71;\n                  break;\n                }\n\n                query = _objectSpread(_objectSpread({}, query), effect.parsedAs.query);\n                resolvedAs = effect.asPath;\n                pathname = effect.resolvedHref;\n                parsed.pathname = effect.resolvedHref;\n                url = (0, _utils).formatWithValidation(parsed);\n                _context.next = 83;\n                break;\n\n              case 71:\n                if (!(effect.type === 'redirect' && effect.newAs)) {\n                  _context.next = 75;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.change(method, effect.newUrl, effect.newAs, options));\n\n              case 75:\n                if (!(effect.type === 'redirect' && effect.destination)) {\n                  _context.next = 80;\n                  break;\n                }\n\n                window.location.href = effect.destination;\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 80:\n                if (!(effect.type === 'refresh')) {\n                  _context.next = 83;\n                  break;\n                }\n\n                window.location.href = as;\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 83:\n                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n\n                if (!(0, _isDynamic).isDynamicRoute(route)) {\n                  _context.next = 99;\n                  break;\n                }\n\n                _parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                asPathname = _parsedAs.pathname;\n                routeRegex = (0, _routeRegex).getRouteRegex(route);\n                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                shouldInterpolate = route === asPathname;\n                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n\n                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                  _context.next = 98;\n                  break;\n                }\n\n                missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                  return !query[param];\n                });\n\n                if (!(missingParams.length > 0)) {\n                  _context.next = 96;\n                  break;\n                }\n\n                if (true) {\n                  console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                }\n\n                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n\n              case 96:\n                _context.next = 99;\n                break;\n\n              case 98:\n                if (shouldInterpolate) {\n                  as = (0, _utils).formatWithValidation(Object.assign({}, _parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: omitParmsFromQuery(query, interpolatedAs.params)\n                  }));\n                } else {\n                  // Merge params into `query`, overwriting any specified in search\n                  Object.assign(query, routeMatch);\n                }\n\n              case 99:\n                Router.events.emit('routeChangeStart', as, routeProps);\n                _context.prev = 100;\n                _context.next = 103;\n                return this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n\n              case 103:\n                routeInfo = _context.sent;\n                _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP; // handle redirect on client-transition\n\n                if (!((__N_SSG || __N_SSP) && props)) {\n                  _context.next = 129;\n                  break;\n                }\n\n                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n                  _context.next = 115;\n                  break;\n                }\n\n                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n                // client-navigation if it is falling back to hard navigation if\n                // it's not\n\n                if (!(destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                  _context.next = 113;\n                  break;\n                }\n\n                parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n                return _context.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n\n              case 113:\n                window.location.href = destination;\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 115:\n                this.isPreview = !!props.__N_PREVIEW; // handle SSG data 404\n\n                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n                  _context.next = 129;\n                  break;\n                }\n\n                _context.prev = 117;\n                _context.next = 120;\n                return this.fetchComponent('/404');\n\n              case 120:\n                notFoundRoute = '/404';\n                _context.next = 126;\n                break;\n\n              case 123:\n                _context.prev = 123;\n                _context.t1 = _context[\"catch\"](117);\n                notFoundRoute = '/_error';\n\n              case 126:\n                _context.next = 128;\n                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                  shallow: false\n                });\n\n              case 128:\n                routeInfo = _context.sent;\n\n              case 129:\n                Router.events.emit('beforeHistoryChange', as, routeProps);\n                this.changeState(method, url, as, options);\n\n                if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref1 = ref.pageProps) === null || ref1 === void 0 ? void 0 : ref1.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  props.pageProps.statusCode = 500;\n                } // shallow routing is only allowed for same page URL changes.\n\n\n                isValidShallowRoute = options.shallow && this.route === route;\n                shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n                resetScroll = shouldScroll ? {\n                  x: 0,\n                  y: 0\n                } : null;\n                _context.next = 137;\n                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll)[\"catch\"](function (e) {\n                  if (e.cancelled) error = error || e;else throw e;\n                });\n\n              case 137:\n                if (!error) {\n                  _context.next = 140;\n                  break;\n                }\n\n                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                throw error;\n\n              case 140:\n                if (false) {}\n\n                Router.events.emit('routeChangeComplete', as, routeProps);\n                return _context.abrupt(\"return\", true);\n\n              case 145:\n                _context.prev = 145;\n                _context.t2 = _context[\"catch\"](100);\n\n                if (!((0, _isError)[\"default\"](_context.t2) && _context.t2.cancelled)) {\n                  _context.next = 149;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", false);\n\n              case 149:\n                throw _context.t2;\n\n              case 150:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[37, 46], [100, 145], [117, 123]]);\n      }));\n\n      function change(_x, _x2, _x3, _x4, _x5) {\n        return _change.apply(this, arguments);\n      }\n\n      return change;\n    }()\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (true) {\n        if (typeof window.history === 'undefined') {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === 'undefined') {\n          console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n          return;\n        }\n      }\n\n      if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        '', as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function () {\n      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, routeProps, loadErrorFail) {\n        var Component, styleSheets, props, _yield$this$fetchComp, routeInfo;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!err.cancelled) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw err;\n\n              case 2:\n                if (!((0, _routeLoader).isAssetError(err) || loadErrorFail)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n\n                window.location.href = as; // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n\n                throw buildCancellationError();\n\n              case 6:\n                _context2.prev = 6;\n\n                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                _context2.next = 10;\n                return this.fetchComponent('/_error');\n\n              case 10:\n                _yield$this$fetchComp = _context2.sent;\n                Component = _yield$this$fetchComp.page;\n                styleSheets = _yield$this$fetchComp.styleSheets;\n\n              case 13:\n                routeInfo = {\n                  props: props,\n                  Component: Component,\n                  styleSheets: styleSheets,\n                  err: err,\n                  error: err\n                };\n\n                if (routeInfo.props) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                _context2.prev = 15;\n                _context2.next = 18;\n                return this.getInitialProps(Component, {\n                  err: err,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 18:\n                routeInfo.props = _context2.sent;\n                _context2.next = 25;\n                break;\n\n              case 21:\n                _context2.prev = 21;\n                _context2.t0 = _context2[\"catch\"](15);\n                console.error('Error in error page `getInitialProps`: ', _context2.t0);\n                routeInfo.props = {};\n\n              case 25:\n                return _context2.abrupt(\"return\", routeInfo);\n\n              case 28:\n                _context2.prev = 28;\n                _context2.t1 = _context2[\"catch\"](6);\n                return _context2.abrupt(\"return\", this.handleRouteInfoError((0, _isError)[\"default\"](_context2.t1) ? _context2.t1 : new Error(_context2.t1 + ''), pathname, query, as, routeProps, true));\n\n              case 31:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[6, 28], [15, 21]]);\n      }));\n\n      function handleRouteInfoError(_x6, _x7, _x8, _x9, _x10, _x11) {\n        return _handleRouteInfoError.apply(this, arguments);\n      }\n\n      return handleRouteInfoError;\n    }()\n  }, {\n    key: \"getRouteInfo\",\n    value: function () {\n      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as, resolvedAs, routeProps) {\n        var _this2 = this;\n\n        var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, __N_RSC, _require, isValidElementType, dataHref, props, _yield$this$_getData, fresh, data;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                existingRouteInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", existingRouteInfo);\n\n              case 4:\n                cachedRouteInfo = undefined; // can only use non-initial route info\n                // cannot reuse route info in development since it can change after HMR\n\n                if (false) {}\n\n                _context3.t0 = cachedRouteInfo;\n\n                if (_context3.t0) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 10;\n                return this.fetchComponent(route).then(function (res) {\n                  return {\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP,\n                    __N_RSC: !!res.page.__next_rsc__\n                  };\n                });\n\n              case 10:\n                _context3.t0 = _context3.sent;\n\n              case 11:\n                routeInfo = _context3.t0;\n                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP, __N_RSC = routeInfo.__N_RSC;\n\n                if (false) {}\n\n                _require = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\"), isValidElementType = _require.isValidElementType;\n\n                if (isValidElementType(Component)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n\n              case 17:\n                if (__N_SSG || __N_SSP || __N_RSC) {\n                  dataHref = this.pageLoader.getDataHref({\n                    href: (0, _utils).formatWithValidation({\n                      pathname: pathname,\n                      query: query\n                    }),\n                    asPath: resolvedAs,\n                    ssg: __N_SSG,\n                    rsc: __N_RSC,\n                    locale: this.locale\n                  });\n                }\n\n                _context3.next = 20;\n                return this._getData(function () {\n                  return __N_SSG || __N_SSP ? fetchNextData(dataHref, _this2.isSsr, false, __N_SSG ? _this2.sdc : _this2.sdr, !!__N_SSG && !_this2.isPreview) : _this2.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n                  {\n                    pathname: pathname,\n                    query: query,\n                    asPath: as,\n                    locale: _this2.locale,\n                    locales: _this2.locales,\n                    defaultLocale: _this2.defaultLocale\n                  });\n                });\n\n              case 20:\n                props = _context3.sent;\n\n                if (!__N_RSC) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                _context3.next = 24;\n                return this._getData(function () {\n                  return _this2._getFlightData(dataHref);\n                });\n\n              case 24:\n                _yield$this$_getData = _context3.sent;\n                fresh = _yield$this$_getData.fresh;\n                data = _yield$this$_getData.data;\n                props.pageProps = Object.assign(props.pageProps, {\n                  __flight_serialized__: data,\n                  __flight_fresh__: fresh\n                });\n\n              case 28:\n                routeInfo.props = props;\n                this.components[route] = routeInfo;\n                return _context3.abrupt(\"return\", routeInfo);\n\n              case 33:\n                _context3.prev = 33;\n                _context3.t1 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", this.handleRouteInfoError((0, _isError)[\"default\"](_context3.t1) ? _context3.t1 : new Error(_context3.t1 + ''), pathname, query, as, routeProps));\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 33]]);\n      }));\n\n      function getRouteInfo(_x12, _x13, _x14, _x15, _x16, _x17) {\n        return _getRouteInfo.apply(this, arguments);\n      }\n\n      return getRouteInfo;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(route, pathname, query, as, data, resetScroll) {\n      this.isFallback = false;\n      this.route = route;\n      this.pathname = pathname;\n      this.query = query;\n      this.asPath = as;\n      return this.notify(data, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split('#'),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split('#'),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split('#'),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === '' || hash === 'top') {\n        window.scrollTo(0, 0);\n        return;\n      } // First we check if the element by id is found\n\n\n      var idEl = document.getElementById(hash);\n\n      if (idEl) {\n        idEl.scrollIntoView();\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(hash)[0];\n\n      if (nameEl) {\n        nameEl.scrollIntoView();\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function () {\n      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {\n        var _this3 = this;\n\n        var asPath,\n            options,\n            parsed,\n            pathname,\n            query,\n            parsedAs,\n            localePathResult,\n            pages,\n            resolvedAs,\n            rewrites,\n            _yield$getClientBuild,\n            rewritesResult,\n            effects,\n            route,\n            _args4 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;\n                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                pathname = parsed.pathname, query = parsed.query;\n\n                if (false) {}\n\n                _context4.next = 7;\n                return this.pageLoader.getPageList();\n\n              case 7:\n                pages = _context4.sent;\n                resolvedAs = asPath;\n\n                if (true) {\n                  _context4.next = 19;\n                  break;\n                }\n\n                _context4.next = 12;\n                return (0, _routeLoader).getClientBuildManifest();\n\n              case 12:\n                _yield$getClientBuild = _context4.sent;\n                rewrites = _yield$getClientBuild.__rewrites;\n                rewritesResult = (0, _resolveRewrites)[\"default\"](addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n                resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = pathname;\n                  url = (0, _utils).formatWithValidation(parsed);\n                }\n\n                _context4.next = 21;\n                break;\n\n              case 19:\n                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n                if (parsed.pathname !== pathname) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = pathname;\n                  url = (0, _utils).formatWithValidation(parsed);\n                }\n\n              case 21:\n                if (false) {}\n\n                return _context4.abrupt(\"return\");\n\n              case 23:\n                _context4.next = 25;\n                return this._preflightRequest({\n                  as: addBasePath(asPath),\n                  cache: true,\n                  pages: pages,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 25:\n                effects = _context4.sent;\n\n                if (effects.type === 'rewrite') {\n                  parsed.pathname = effects.resolvedHref;\n                  pathname = effects.resolvedHref;\n                  query = _objectSpread(_objectSpread({}, query), effects.parsedAs.query);\n                  resolvedAs = effects.asPath;\n                  url = (0, _utils).formatWithValidation(parsed);\n                }\n\n                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                _context4.next = 30;\n                return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {\n                  return isSsg ? fetchNextData(_this3.pageLoader.getDataHref({\n                    href: url,\n                    asPath: resolvedAs,\n                    ssg: true,\n                    locale: typeof options.locale !== 'undefined' ? options.locale : _this3.locale\n                  }), false, false, _this3.sdc, true) : false;\n                }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n\n              case 30:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function prefetch(_x18) {\n        return _prefetch.apply(this, arguments);\n      }\n\n      return prefetch;\n    }()\n  }, {\n    key: \"fetchComponent\",\n    value: function () {\n      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {\n        var _this4 = this;\n\n        var cancelled, cancel, handleCancelled, componentResult;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                cancelled = false;\n\n                cancel = this.clc = function () {\n                  cancelled = true;\n                };\n\n                handleCancelled = function handleCancelled() {\n                  if (cancelled) {\n                    var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n                    error.cancelled = true;\n                    throw error;\n                  }\n\n                  if (cancel === _this4.clc) {\n                    _this4.clc = null;\n                  }\n                };\n\n                _context5.prev = 3;\n                _context5.next = 6;\n                return this.pageLoader.loadPage(route);\n\n              case 6:\n                componentResult = _context5.sent;\n                handleCancelled();\n                return _context5.abrupt(\"return\", componentResult);\n\n              case 11:\n                _context5.prev = 11;\n                _context5.t0 = _context5[\"catch\"](3);\n                handleCancelled();\n                throw _context5.t0;\n\n              case 15:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[3, 11]]);\n      }));\n\n      function fetchComponent(_x19) {\n        return _fetchComponent.apply(this, arguments);\n      }\n\n      return fetchComponent;\n    }()\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this5 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this5.clc) {\n          _this5.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error('Loading initial props cancelled');\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      var _this6 = this;\n\n      var _URL2 = new URL(dataHref, window.location.href),\n          cacheKey = _URL2.href;\n\n      if (!this.isPreview && this.sdc[cacheKey]) {\n        return Promise.resolve({\n          fresh: false,\n          data: this.sdc[cacheKey]\n        });\n      }\n\n      return fetchNextData(dataHref, true, true, this.sdc, false).then(function (serialized) {\n        _this6.sdc[cacheKey] = serialized;\n        return {\n          fresh: true,\n          data: serialized\n        };\n      });\n    }\n  }, {\n    key: \"_preflightRequest\",\n    value: function () {\n      var _preflightRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(options) {\n        var ref, cleanedAs, fns, requiresPreflight, preflight, parsed, fsPathname, matchedPage, resolvedHref, cleanRedirect, _prepareUrlAs4, newUrl, newAs;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, this.locale);\n                _context6.next = 3;\n                return this.pageLoader.getMiddlewareList();\n\n              case 3:\n                fns = _context6.sent;\n                requiresPreflight = fns.some(function (_ref2) {\n                  var _ref3 = _slicedToArray(_ref2, 2),\n                      middleware = _ref3[0],\n                      isSSR = _ref3[1];\n\n                  return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n                });\n\n                if (requiresPreflight) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  type: 'next'\n                });\n\n              case 7:\n                _context6.next = 9;\n                return this._getPreflightData({\n                  preflightHref: options.as,\n                  shouldCache: options.cache\n                });\n\n              case 9:\n                preflight = _context6.sent;\n\n                if (!((ref = preflight.rewrite) === null || ref === void 0 ? void 0 : ref.startsWith('/'))) {\n                  _context6.next = 15;\n                  break;\n                }\n\n                parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n                fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n\n                if (options.pages.includes(fsPathname)) {\n                  matchedPage = true;\n                  resolvedHref = fsPathname;\n                } else {\n                  resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n\n                  if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                    matchedPage = true;\n                  }\n                }\n\n                return _context6.abrupt(\"return\", {\n                  type: 'rewrite',\n                  asPath: parsed.pathname,\n                  parsedAs: parsed,\n                  matchedPage: matchedPage,\n                  resolvedHref: resolvedHref\n                });\n\n              case 15:\n                if (!preflight.redirect) {\n                  _context6.next = 21;\n                  break;\n                }\n\n                if (!preflight.redirect.startsWith('/')) {\n                  _context6.next = 20;\n                  break;\n                }\n\n                cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n                _prepareUrlAs4 = prepareUrlAs(this, cleanRedirect, cleanRedirect), newUrl = _prepareUrlAs4.url, newAs = _prepareUrlAs4.as;\n                return _context6.abrupt(\"return\", {\n                  type: 'redirect',\n                  newUrl: newUrl,\n                  newAs: newAs\n                });\n\n              case 20:\n                return _context6.abrupt(\"return\", {\n                  type: 'redirect',\n                  destination: preflight.redirect\n                });\n\n              case 21:\n                if (!(preflight.refresh && !preflight.ssr)) {\n                  _context6.next = 23;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  type: 'refresh'\n                });\n\n              case 23:\n                return _context6.abrupt(\"return\", {\n                  type: 'next'\n                });\n\n              case 24:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _preflightRequest(_x20) {\n        return _preflightRequest2.apply(this, arguments);\n      }\n\n      return _preflightRequest;\n    }()\n  }, {\n    key: \"_getPreflightData\",\n    value: function _getPreflightData(params) {\n      var _this7 = this;\n\n      var preflightHref = params.preflightHref,\n          _params$shouldCache = params.shouldCache,\n          shouldCache = _params$shouldCache === void 0 ? false : _params$shouldCache;\n\n      var _URL3 = new URL(preflightHref, window.location.href),\n          cacheKey = _URL3.href;\n\n      if (false) {}\n\n      return fetch(preflightHref, {\n        method: 'HEAD',\n        credentials: 'same-origin',\n        headers: {\n          'x-middleware-preflight': '1'\n        }\n      }).then(function (res) {\n        if (!res.ok) {\n          throw new Error(\"Failed to preflight request\");\n        }\n\n        return {\n          redirect: res.headers.get('Location'),\n          refresh: res.headers.has('x-middleware-refresh'),\n          rewrite: res.headers.get('x-middleware-rewrite'),\n          ssr: !!res.headers.get('x-middleware-ssr')\n        };\n      }).then(function (data) {\n        if (shouldCache) {\n          _this7.sde[cacheKey] = data;\n        }\n\n        return data;\n      })[\"catch\"](function (err) {\n        delete _this7.sde[cacheKey];\n        throw err;\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components['/_app'].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils).loadGetInitialProps(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"abortComponentLoad\",\n    value: function abortComponentLoad(as, routeProps) {\n      if (this.clc) {\n        Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n        this.clc();\n        this.clc = null;\n      }\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(data, resetScroll) {\n      return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n  }]);\n\n  return Router;\n}();\n\nRouter.events = (0, _mitt)[\"default\"]();\nexports[\"default\"] = Router;\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNiQSw4Q0FBNkM7QUFDekNHLEVBQUFBLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCx1QkFBQSxHQUEwQkUsZUFBMUI7QUFDQUYsaUJBQUEsR0FBb0JHLFNBQXBCO0FBQ0FILGlCQUFBLEdBQW9CSSxTQUFwQjtBQUNBSixtQkFBQSxHQUFzQkssV0FBdEI7QUFDQUwsbUJBQUEsR0FBc0JNLFdBQXRCO0FBQ0FOLG1CQUFBLEdBQXNCTyxXQUF0QjtBQUNBUCxrQkFBQSxHQUFxQlEsVUFBckI7QUFDQVIscUJBQUEsR0FBd0JTLGFBQXhCO0FBQ0FULG1CQUFBLEdBQXNCVSxXQUF0QjtBQUNBVixrQkFBQSxHQUFrQixLQUFLLENBQXZCOztBQUNBLElBQUlXLHVCQUF1QixHQUFHQyxtQkFBTyxDQUFDLDZHQUFELENBQXJDOztBQUNBLElBQUlDLFlBQVksR0FBR0QsbUJBQU8sQ0FBQyxxRkFBRCxDQUExQjs7QUFDQSxJQUFJRSxRQUFRLEdBQUdDLHNCQUFzQixDQUFDSCxtQkFBTyxDQUFDLHVFQUFELENBQVIsQ0FBckM7O0FBQ0EsSUFBSUksb0JBQW9CLEdBQUdKLG1CQUFPLENBQUMsdUdBQUQsQ0FBbEM7O0FBQ0EsSUFBSUssb0JBQW9CLEdBQUdMLG1CQUFPLENBQUMsd0dBQUQsQ0FBbEM7O0FBQ0EsSUFBSU0sS0FBSyxHQUFHSCxzQkFBc0IsQ0FBQ0gsbUJBQU8sQ0FBQyw0REFBRCxDQUFSLENBQWxDOztBQUNBLElBQUlPLE1BQU0sR0FBR1AsbUJBQU8sQ0FBQyw4REFBRCxDQUFwQjs7QUFDQSxJQUFJUSxVQUFVLEdBQUdSLG1CQUFPLENBQUMsMEZBQUQsQ0FBeEI7O0FBQ0EsSUFBSVMsaUJBQWlCLEdBQUdULG1CQUFPLENBQUMsMEdBQUQsQ0FBL0I7O0FBQ0EsSUFBSVUsWUFBWSxHQUFHVixtQkFB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QUs1QixHQUFULEVBQWM7QUFDVm5ELFFBQUFBLE1BQU0sQ0FBQzhDLE1BQVAsQ0FBY3VDLElBQWQsQ0FBbUIsa0JBQW5CLEVBQXVDbk8sc0JBQXNCLEVBQTdELEVBQWlFOEYsRUFBakUsRUFBcUUrSCxVQUFyRTtBQUNBLGFBQUs1QixHQUFMO0FBQ0EsYUFBS0EsR0FBTCxHQUFXLElBQVg7QUFDSDtBQUNKOzs7V0FDRCxnQkFBTy9ELElBQVAsRUFBYTJJLFdBQWIsRUFBMEI7QUFDdEIsYUFBTyxLQUFLN0UsR0FBTCxDQUFTOUQsSUFBVCxFQUFlLEtBQUtpRCxVQUFMLENBQWdCLE9BQWhCLEVBQXlCaEMsU0FBeEMsRUFBbUQwSCxXQUFuRCxDQUFQO0FBQ0g7Ozs7OztBQUVML0gsTUFBTSxDQUFDOEMsTUFBUCxHQUFnQixDQUFDLEdBQUc3TSxLQUFKLGNBQWhCO0FBQ0FsQixrQkFBQSxHQUFrQmlMLE1BQWxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzPzg2ODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldERvbWFpbkxvY2FsZSA9IGdldERvbWFpbkxvY2FsZTtcbmV4cG9ydHMuYWRkTG9jYWxlID0gYWRkTG9jYWxlO1xuZXhwb3J0cy5kZWxMb2NhbGUgPSBkZWxMb2NhbGU7XG5leHBvcnRzLmhhc0Jhc2VQYXRoID0gaGFzQmFzZVBhdGg7XG5leHBvcnRzLmFkZEJhc2VQYXRoID0gYWRkQmFzZVBhdGg7XG5leHBvcnRzLmRlbEJhc2VQYXRoID0gZGVsQmFzZVBhdGg7XG5leHBvcnRzLmlzTG9jYWxVUkwgPSBpc0xvY2FsVVJMO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUFzID0gaW50ZXJwb2xhdGVBcztcbmV4cG9ydHMucmVzb2x2ZUhyZWYgPSByZXNvbHZlSHJlZjtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xudmFyIF9yb3V0ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xudmFyIF9pc0Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWVycm9yXCIpKTtcbnZhciBfZGVub3JtYWxpemVQYWdlUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zZXJ2ZXIvZGVub3JtYWxpemUtcGFnZS1wYXRoXCIpO1xudmFyIF9ub3JtYWxpemVMb2NhbGVQYXRoID0gcmVxdWlyZShcIi4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoXCIpO1xudmFyIF9taXR0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9wYXJzZVJlbGF0aXZlVXJsID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xudmFyIF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xudmFyIF9yZXNvbHZlUmV3cml0ZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXNcIikpO1xudmFyIF9yb3V0ZU1hdGNoZXIgPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1tYXRjaGVyXCIpO1xudmFyIF9yb3V0ZVJlZ2V4ID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtcmVnZXhcIik7XG52YXIgX2dldE1pZGRsZXdhcmVSZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1taWRkbGV3YXJlLXJlZ2V4XCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxubGV0IGRldGVjdERvbWFpbkxvY2FsZTtcbmlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZSgnLi4vaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpLmRldGVjdERvbWFpbkxvY2FsZTtcbn1cbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwge1xuICAgICAgICBjYW5jZWxsZWQ6IHRydWVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aCwgcHJlZml4KSB7XG4gICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCAhcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBjb25zdCBwYXRobmFtZSA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKTtcbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChgJHtwcmVmaXh9JHtwYXRobmFtZX1gKSArIHBhdGguc3Vic3RyKHBhdGhuYW1lLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBnZXREb21haW5Mb2NhbGUocGF0aCwgbG9jYWxlLCBsb2NhbGVzLCBkb21haW5Mb2NhbGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgbG9jYWxlID0gbG9jYWxlIHx8ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCBsb2NhbGUpO1xuICAgICAgICBpZiAoZGV0ZWN0ZWREb21haW4pIHtcbiAgICAgICAgICAgIHJldHVybiBgaHR0cCR7ZGV0ZWN0ZWREb21haW4uaHR0cCA/ICcnIDogJ3MnfTovLyR7ZGV0ZWN0ZWREb21haW4uZG9tYWlufSR7YmFzZVBhdGggfHwgJyd9JHtsb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHtsb2NhbGV9YH0ke3BhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZExvY2FsZShwYXRoLCBsb2NhbGUsIGRlZmF1bHRMb2NhbGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCBwYXRobmFtZSA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKTtcbiAgICAgICAgY29uc3QgcGF0aExvd2VyID0gcGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbG9jYWxlTG93ZXIgPSBsb2NhbGUgJiYgbG9jYWxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsb2NhbGUgJiYgbG9jYWxlICE9PSBkZWZhdWx0TG9jYWxlICYmICFwYXRoTG93ZXIuc3RhcnRzV2l0aCgnLycgKyBsb2NhbGVMb3dlciArICcvJykgJiYgcGF0aExvd2VyICE9PSAnLycgKyBsb2NhbGVMb3dlciA/IGFkZFBhdGhQcmVmaXgocGF0aCwgJy8nICsgbG9jYWxlKSA6IHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gZGVsTG9jYWxlKHBhdGgsIGxvY2FsZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgICAgICBjb25zdCBwYXRoTG93ZXIgPSBwYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBsb2NhbGVMb3dlciA9IGxvY2FsZSAmJiBsb2NhbGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZSAmJiAocGF0aExvd2VyLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlTG93ZXIgKyAnLycpIHx8IHBhdGhMb3dlciA9PT0gJy8nICsgbG9jYWxlTG93ZXIpID8gKHBhdGhuYW1lLmxlbmd0aCA9PT0gbG9jYWxlLmxlbmd0aCArIDEgPyAnLycgOiAnJykgKyBwYXRoLnN1YnN0cihsb2NhbGUubGVuZ3RoICsgMSkgOiBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIHBhdGhOb1F1ZXJ5SGFzaChwYXRoKSB7XG4gICAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICAgIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICAgIGlmIChxdWVyeUluZGV4ID4gLTEgfHwgaGFzaEluZGV4ID4gLTEpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgIHJldHVybiBwYXRoID09PSBiYXNlUGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgoYmFzZVBhdGggKyAnLycpO1xufVxuZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aCkge1xuICAgIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gICAgcmV0dXJuIGFkZFBhdGhQcmVmaXgocGF0aCwgYmFzZVBhdGgpO1xufVxuZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2VQYXRoLmxlbmd0aCk7XG4gICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkgcGF0aCA9IGAvJHtwYXRofWA7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBpc0xvY2FsVVJMKHVybCkge1xuICAgIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnIycpIHx8IHVybC5zdGFydHNXaXRoKCc/JykpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxuICAgICAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uT3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSB7XG4gICAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gJyc7XG4gICAgY29uc3QgZHluYW1pY1JlZ2V4ID0gKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHJvdXRlKTtcbiAgICBjb25zdCBkeW5hbWljR3JvdXBzID0gZHluYW1pY1JlZ2V4Lmdyb3VwcztcbiAgICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9IC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKGR5bmFtaWNSZWdleCkoYXNQYXRobmFtZSkgOiAnJykgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5O1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3Vwcyk7XG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgJyc7XG4gICAgICAgIGNvbnN0IHsgcmVwZWF0ICwgb3B0aW9uYWwgIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gYFske3JlcGVhdCA/ICcuLi4nIDogJyd9JHtwYXJhbX1dYDtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAoc2VnbWVudCk9PmVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KVxuICAgICAgICApLmpvaW4oJy8nKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpIHx8ICcvJyk7XG4gICAgfSkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSAnJyAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuICAgICAgICA7XG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGVcbiAgICB9O1xufVxuZnVuY3Rpb24gb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBmaWx0ZXJlZFF1ZXJ5ID0ge1xuICAgIH07XG4gICAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgaWYgKCFwYXJhbXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgZmlsdGVyZWRRdWVyeVtrZXldID0gcXVlcnlba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZFF1ZXJ5O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUhyZWYocm91dGVyLCBocmVmLCByZXNvbHZlQXMpIHtcbiAgICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICAgIGxldCBiYXNlO1xuICAgIGxldCB1cmxBc1N0cmluZyA9IHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihocmVmKTtcbiAgICAvLyByZXBlYXRlZCBzbGFzaGVzIGFuZCBiYWNrc2xhc2hlcyBpbiB0aGUgVVJMIGFyZSBjb25zaWRlcmVkXG4gICAgLy8gaW52YWxpZCBhbmQgd2lsbCBuZXZlciBtYXRjaCBhIE5leHQuanMgcGFnZS9maWxlXG4gICAgY29uc3QgdXJsUHJvdG9NYXRjaCA9IHVybEFzU3RyaW5nLm1hdGNoKC9eW2EtekEtWl17MSx9OlxcL1xcLy8pO1xuICAgIGNvbnN0IHVybEFzU3RyaW5nTm9Qcm90byA9IHVybFByb3RvTWF0Y2ggPyB1cmxBc1N0cmluZy5zdWJzdHIodXJsUHJvdG9NYXRjaFswXS5sZW5ndGgpIDogdXJsQXNTdHJpbmc7XG4gICAgY29uc3QgdXJsUGFydHMgPSB1cmxBc1N0cmluZ05vUHJvdG8uc3BsaXQoJz8nKTtcbiAgICBpZiAoKHVybFBhcnRzWzBdIHx8ICcnKS5tYXRjaCgvKFxcL1xcL3xcXFxcKS8pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgaHJlZiBwYXNzZWQgdG8gbmV4dC9yb3V0ZXI6ICR7dXJsQXNTdHJpbmd9LCByZXBlYXRlZCBmb3J3YXJkLXNsYXNoZXMgKC8vKSBvciBiYWNrc2xhc2hlcyBcXFxcIGFyZSBub3QgdmFsaWQgaW4gdGhlIGhyZWZgKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFVybCA9ICgwLCBfdXRpbHMpLm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyh1cmxBc1N0cmluZ05vUHJvdG8pO1xuICAgICAgICB1cmxBc1N0cmluZyA9ICh1cmxQcm90b01hdGNoID8gdXJsUHJvdG9NYXRjaFswXSA6ICcnKSArIG5vcm1hbGl6ZWRVcmw7XG4gICAgfVxuICAgIC8vIFJldHVybiBiZWNhdXNlIGl0IGNhbm5vdCBiZSByb3V0ZWQgYnkgdGhlIE5leHQuanMgcm91dGVyXG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybEFzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiYXNlID0gbmV3IFVSTCh1cmxBc1N0cmluZy5zdGFydHNXaXRoKCcjJykgPyByb3V0ZXIuYXNQYXRoIDogcm91dGVyLnBhdGhuYW1lLCAnaHR0cDovL24nKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIC8gZm9yIGludmFsaWQgYXNQYXRoIHZhbHVlcyBlLmcuIC8vXG4gICAgICAgIGJhc2UgPSBuZXcgVVJMKCcvJywgJ2h0dHA6Ly9uJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSk7XG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChmaW5hbFVybC5wYXRobmFtZSk7XG4gICAgICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9ICcnO1xuICAgICAgICBpZiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKGZpbmFsVXJsLnBhdGhuYW1lKSAmJiBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiYgcmVzb2x2ZUFzKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9ICgwLCBfcXVlcnlzdHJpbmcpLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0ICwgcGFyYW1zICB9ID0gaW50ZXJwb2xhdGVBcyhmaW5hbFVybC5wYXRobmFtZSwgZmluYWxVcmwucGF0aG5hbWUsIHF1ZXJ5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRBcyA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgcGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW4gPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpIDogZmluYWxVcmwuaHJlZjtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgIGludGVycG9sYXRlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICBdIDogcmVzb2x2ZWRIcmVmO1xuICAgIH0gY2F0Y2ggKF8xKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICB1cmxBc1N0cmluZ1xuICAgICAgICBdIDogdXJsQXNTdHJpbmc7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKTtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmw7XG59XG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyLCB1cmwsIGFzKSB7XG4gICAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gICAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihyb3V0ZXIsIHVybCwgdHJ1ZSk7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKTtcbiAgICBjb25zdCBocmVmSGFkT3JpZ2luID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICBjb25zdCBhc0hhZE9yaWdpbiA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcbiAgICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcztcbiAgICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZIYWRPcmlnaW4gPyByZXNvbHZlZEhyZWYgOiBhZGRCYXNlUGF0aChyZXNvbHZlZEhyZWYpO1xuICAgIGNvbnN0IHByZXBhcmVkQXMgPSBhcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVIcmVmKHJvdXRlciwgYXMpKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgICAgIGFzOiBhc0hhZE9yaWdpbiA/IHByZXBhcmVkQXMgOiBhZGRCYXNlUGF0aChwcmVwYXJlZEFzKVxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcykge1xuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKCgwLCBfZGVub3JtYWxpemVQYWdlUGF0aCkuZGVub3JtYWxpemVQYWdlUGF0aChwYXRobmFtZSkpO1xuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICBwYWdlcy5zb21lKChwYWdlKT0+e1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYWdlKSAmJiAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbn1cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5ICYmICEhZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHYgPSAnX19uZXh0JztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgfVxufSgpO1xuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKCdTU0dfREFUQV9OT1RfRk9VTkQnKTtcbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cywgb3B0cykge1xuICAgIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAgICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgICAgIC8vID4gb3B0aW9uLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAgICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgICB9KS50aGVuKChyZXMpPT57XG4gICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPiAxICYmIHJlcy5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBTU0dfREFUQV9OT1RfRk9VTkRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHMudGV4dCA/IHJlcy50ZXh0KCkgOiByZXMuanNvbigpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIsIHRleHQsIGluZmxpZ2h0Q2FjaGUsIHBlcnNpc3RDYWNoZSkge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxLCB7XG4gICAgICAgIHRleHRcbiAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAvLyBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhcyBjYXVzZWRcbiAgICAgICAgLy8gb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG8gYW4gaW5maW5pdGVcbiAgICAgICAgLy8gbG9vcC5cbiAgICAgICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgICAgICAgKDAsIF9yb3V0ZUxvYWRlcikubWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufVxuY2xhc3MgUm91dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZSwgcXVlcnksIGFzLCB7IGluaXRpYWxQcm9wcyAsIHBhZ2VMb2FkZXIgLCBBcHAgLCB3cmFwQXBwICwgQ29tcG9uZW50ICwgZXJyICwgc3Vic2NyaXB0aW9uICwgaXNGYWxsYmFjayAsIGxvY2FsZSAsIGxvY2FsZXMgLCBkZWZhdWx0TG9jYWxlICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAgfSl7XG4gICAgICAgIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gICAgICAgIHRoaXMuc2RjID0ge1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbi1mbGlnaHQgU2VydmVyIERhdGEgUmVxdWVzdHMsIGZvciBkZWR1cGluZ1xuICAgICAgICB0aGlzLnNkciA9IHtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW4tZmxpZ2h0IG1pZGRsZXdhcmUgcHJlZmxpZ2h0IHJlcXVlc3RzXG4gICAgICAgIHRoaXMuc2RlID0ge1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pZHggPSAwO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgICAgICAgICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgICAgICAgICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgICAgICAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdyZXBsYWNlU3RhdGUnLCAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMpLmdldFVSTCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XG4gICAgICAgICAgICBjb25zdCB7IHVybCAsIGFzICwgb3B0aW9ucyAsIGlkeCAgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkeCAhPT0gaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IEpTT04ucGFyc2Uodik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lkeCA9IGlkeDtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gdGhpcy5hc1BhdGggJiYgcGF0aG5hbWUgPT09IHRoaXMucGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgICAgICB0aGlzLnJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSA9IHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgICAgICAgICAgIF9fTl9SU0M6ICEhKChyZWYgPSBDb21wb25lbnQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLl9fbmV4dF9yc2NfXylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBBcHAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPSAoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmFzUGF0aCA9IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcztcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0ZhbGxiYWNrID0gaXNGYWxsYmFjaztcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xuICAgICAgICB0aGlzLmlzUHJldmlldyA9ICEhaXNQcmV2aWV3O1xuICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhIWRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgICAgICAgaWYgKGFzLnN1YnN0cigwLCAyKSAhPT0gJy8vJykge1xuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdyZXBsYWNlU3RhdGUnLCAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMpLmdldFVSTCgpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHB1c2godXJsLCBhcywgb3B0aW9ucyA9IHtcbiAgICB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSB3aGVuIHdlIHVwZGF0ZSBoaXN0b3J5IGJlZm9yZSByb3V0ZSBjaGFuZ2VcbiAgICAgICAgICAgIC8vIGlzIGNvbXBsZXRlLCBhcyB0aGUgcG9wc3RhdGUgZXZlbnQgc2hvdWxkIGhhbmRsZSB0aGlzIGNhcHR1cmUuXG4gICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBzY3JvbGwgcG9zaXRpb24gcmlnaHQgYmVmb3JlIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZTpcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZSgncHVzaFN0YXRlJywgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zID0ge1xuICAgIH0pIHtcbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgaWYgKCFpc0xvY2FsVVJMKHVybCkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNob3VsZFJlc29sdmVIcmVmID0gb3B0aW9ucy5faCB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCBwYXRoTm9RdWVyeUhhc2godXJsKSA9PT0gcGF0aE5vUXVlcnlIYXNoKGFzKTtcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICBpZiAob3B0aW9ucy5faCkge1xuICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gdGhpcy5sb2NhbGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IHRoaXMuZGVmYXVsdExvY2FsZSA6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChoYXNCYXNlUGF0aCh1cmwpID8gZGVsQmFzZVBhdGgodXJsKSA6IHVybCwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICAgICAgICAgIGlmICghKChyZWYgPSB0aGlzLmxvY2FsZXMpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmluY2x1ZGVzKHRoaXMubG9jYWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRMb2NhbGUocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZSh0aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gZGVsQmFzZVBhdGgoYXMpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHthZGRCYXNlUGF0aChgJHt0aGlzLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke3RoaXMubG9jYWxlfWB9JHthc05vQmFzZVBhdGggPT09ICcvJyA/ICcnIDogYXNOb0Jhc2VQYXRofWAgfHwgJy8nKX1gO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLl9oKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2hhbGxvdyA9ZmFsc2UgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCByb3V0ZVByb3BzID0ge1xuICAgICAgICAgICAgc2hhbGxvd1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQodGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXMgPSBhZGRCYXNlUGF0aChhZGRMb2NhbGUoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsIG9wdGlvbnMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhcztcbiAgICAgICAgbGV0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IHRoaXMubG9jYWxlO1xuICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgaWYgKCFvcHRpb25zLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXM7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmVMaXN0KCksIFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAgICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xuICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVsQmFzZVBhdGgocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdChhZGRCYXNlUGF0aChhZGRMb2NhbGUoY2xlYW5lZEFzLCB0aGlzLmxvY2FsZSkpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpXG4gICAgICAgICAgICAgICAgLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaHJlZjogXCIke3VybH1cIiBhbmQgYXM6IFwiJHthc31cIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXNgICsgYFxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmVzb2x2ZWRBcyksIHRoaXMubG9jYWxlKTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgdGhpcy5fcHJlZmxpZ2h0UmVxdWVzdCh7XG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIGNhY2hlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZXdyaXRlJykge1xuICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgLi4uZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGVmZmVjdC5hc1BhdGg7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBlZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlZmZlY3QudHlwZSA9PT0gJ3JlZGlyZWN0JyAmJiBlZmZlY3QubmV3QXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIGVmZmVjdC5uZXdVcmwsIGVmZmVjdC5uZXdBcywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGVmZmVjdC5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWZyZXNoJykge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyb3V0ZSk7XG4gICAgICAgICAgICBjb25zdCByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5W3BhcmFtXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke3Nob3VsZEludGVycG9sYXRlID8gYEludGVycG9sYXRpbmcgaHJlZmAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICsgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChzaG91bGRJbnRlcnBvbGF0ZSA/IGBUaGUgcHJvdmlkZWQgXFxgaHJlZlxcYCAoJHt1cmx9KSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoJHttaXNzaW5nUGFyYW1zLmpvaW4oJywgJyl9KSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIGAgOiBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgKSArIGBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzLyR7c2hvdWxkSW50ZXJwb2xhdGUgPyAnaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZCcgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIH0sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlZiwgcmVmMTtcbiAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcmVzb2x2ZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICBsZXQgeyBlcnJvciAsIHByb3BzICwgX19OX1NTRyAsIF9fTl9TU1AgIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgICAgICAgIGlmICgoX19OX1NTRyB8fCBfX05fU1NQKSAmJiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5wYWdlUHJvcHMgJiYgcHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSAmJiBwcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlzUHJldmlldyA9ICEhcHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnLzQwNCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0JztcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvX2Vycm9yJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhub3RGb3VuZFJvdXRlLCBub3RGb3VuZFJvdXRlLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLl9oICYmIHBhdGhuYW1lID09PSAnL19lcnJvcicgJiYgKChyZWYgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKHJlZjEgPSByZWYucGFnZVByb3BzKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgIHByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZTtcbiAgICAgICAgICAgIHZhciBfc2Nyb2xsO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9zY3JvbGwgPSBvcHRpb25zLnNjcm9sbCkgIT09IG51bGwgJiYgX3Njcm9sbCAhPT0gdm9pZCAwID8gX3Njcm9sbCA6ICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGNsZWFuZWRBcywgcm91dGVJbmZvLCBmb3JjZWRTY3JvbGwgIT09IG51bGwgJiYgZm9yY2VkU2Nyb2xsICE9PSB2b2lkIDAgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbCkuY2F0Y2goKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSBlcnJvciA9IGVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gdGhpcy5sb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRXJyb3IpLmRlZmF1bHQoZXJyMSkgJiYgZXJyMS5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnIxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyA9IHtcbiAgICB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8ICgwLCBfdXRpbHMpLmdldFVSTCgpICE9PSBhcykge1xuICAgICAgICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZHg6IHRoaXMuX2lkeCA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9pZHggOiB0aGlzLl9pZHggKyAxXG4gICAgICAgICAgICB9LCAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAgICAgJycsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVMb2FkZXIpLmlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgICAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgICAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBDb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgc3R5bGVTaGVldHM7XG4gICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHN0eWxlU2hlZXRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICh7IHBhZ2U6IENvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnL19lcnJvcicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgJycpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSb3V0ZUluZm8ocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHJvdXRlUHJvcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUm91dGVJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdSb3V0ZUluZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdSb3V0ZUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2FjaGVkUm91dGVJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gY2FuIG9ubHkgdXNlIG5vbi1pbml0aWFsIHJvdXRlIGluZm9cbiAgICAgICAgICAgIC8vIGNhbm5vdCByZXVzZSByb3V0ZSBpbmZvIGluIGRldmVsb3BtZW50IHNpbmNlIGl0IGNhbiBjaGFuZ2UgYWZ0ZXIgSE1SXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiYgZXhpc3RpbmdSb3V0ZUluZm8gJiYgISgnaW5pdGlhbCcgaW4gZXhpc3RpbmdSb3V0ZUluZm8pKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkUm91dGVJbmZvID0gZXhpc3RpbmdSb3V0ZUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9SU0M6ICEhcmVzLnBhZ2UuX19uZXh0X3JzY19fXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCB7IENvbXBvbmVudCAsIF9fTl9TU0cgLCBfX05fU1NQICwgX19OX1JTQyAgfSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhSHJlZjtcbiAgICAgICAgICAgIGlmIChfX05fU1NHIHx8IF9fTl9TU1AgfHwgX19OX1JTQykge1xuICAgICAgICAgICAgICAgIGRhdGFIcmVmID0gdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBzc2c6IF9fTl9TU0csXG4gICAgICAgICAgICAgICAgICAgIHJzYzogX19OX1JTQyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBhd2FpdCB0aGlzLl9nZXREYXRhKCgpPT5fX05fU1NHIHx8IF9fTl9TU1AgPyBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyLCBmYWxzZSwgX19OX1NTRyA/IHRoaXMuc2RjIDogdGhpcy5zZHIsICEhX19OX1NTRyAmJiAhdGhpcy5pc1ByZXZpZXcpIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKF9fTl9SU0MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZyZXNoICwgZGF0YSAgfSA9IGF3YWl0IHRoaXMuX2dldERhdGEoKCk9PnRoaXMuX2dldEZsaWdodERhdGEoZGF0YUhyZWYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHByb3BzLnBhZ2VQcm9wcywge1xuICAgICAgICAgICAgICAgICAgICBfX2ZsaWdodF9zZXJpYWxpemVkX186IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIF9fZmxpZ2h0X2ZyZXNoX186IGZyZXNoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIpID8gZXJyIDogbmV3IEVycm9yKGVyciArICcnKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5hc1BhdGggPSBhcztcbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpO1xuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgaWYgKGhhc2ggPT09ICcnIHx8IGhhc2ggPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpO1xuICAgICAgICBpZiAoaWRFbCkge1xuICAgICAgICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaClbMF07XG4gICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybElzTmV3KGFzUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi8gYXN5bmMgcHJlZmV0Y2godXJsLCBhc1BhdGggPSB1cmwsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgbGV0IHJld3JpdGVzO1xuICAgICAgICAgICAgKHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH0gPSBhd2FpdCAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpO1xuICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdChhZGRCYXNlUGF0aChhZGRMb2NhbGUoYXNQYXRoLCB0aGlzLmxvY2FsZSkpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKVxuICAgICAgICAgICAgLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVmZmVjdHMgPSBhd2FpdCB0aGlzLl9wcmVmbGlnaHRSZXF1ZXN0KHtcbiAgICAgICAgICAgIGFzOiBhZGRCYXNlUGF0aChhc1BhdGgpLFxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlZmZlY3RzLnR5cGUgPT09ICdyZXdyaXRlJykge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZWZmZWN0cy5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGVmZmVjdHMucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgLi4uZWZmZWN0cy5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBlZmZlY3RzLmFzUGF0aDtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyhyb3V0ZSkudGhlbigoaXNTc2cpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU3NnID8gZmV0Y2hOZXh0RGF0YSh0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgc3NnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSA6IHRoaXMubG9jYWxlXG4gICAgICAgICAgICAgICAgfSksIGZhbHNlLCBmYWxzZSwgdGhpcy5zZGMsIHRydWUpIDogZmFsc2U7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSwgXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZSkge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9IHRoaXMuY2xjID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9ICgpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImApO1xuICAgICAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldERhdGEoZm4pIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKSB7XG4gICAgICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmICghdGhpcy5pc1ByZXZpZXcgJiYgdGhpcy5zZGNbY2FjaGVLZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBmcmVzaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5zZGNbY2FjaGVLZXldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdHJ1ZSwgdHJ1ZSwgdGhpcy5zZGMsIGZhbHNlKS50aGVuKChzZXJpYWxpemVkKT0+e1xuICAgICAgICAgICAgdGhpcy5zZGNbY2FjaGVLZXldID0gc2VyaWFsaXplZDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJlc2g6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogc2VyaWFsaXplZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9wcmVmbGlnaHRSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKGhhc0Jhc2VQYXRoKG9wdGlvbnMuYXMpID8gZGVsQmFzZVBhdGgob3B0aW9ucy5hcykgOiBvcHRpb25zLmFzLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgIGNvbnN0IGZucyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlTGlzdCgpO1xuICAgICAgICBjb25zdCByZXF1aXJlc1ByZWZsaWdodCA9IGZucy5zb21lKChbbWlkZGxld2FyZSwgaXNTU1JdKT0+e1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIoKDAsIF9nZXRNaWRkbGV3YXJlUmVnZXgpLmdldE1pZGRsZXdhcmVSZWdleChtaWRkbGV3YXJlLCAhaXNTU1IpKShjbGVhbmVkQXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXF1aXJlc1ByZWZsaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbmV4dCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZmxpZ2h0ID0gYXdhaXQgdGhpcy5fZ2V0UHJlZmxpZ2h0RGF0YSh7XG4gICAgICAgICAgICBwcmVmbGlnaHRIcmVmOiBvcHRpb25zLmFzLFxuICAgICAgICAgICAgc2hvdWxkQ2FjaGU6IG9wdGlvbnMuY2FjaGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgocmVmID0gcHJlZmxpZ2h0LnJld3JpdGUpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChoYXNCYXNlUGF0aChwcmVmbGlnaHQucmV3cml0ZSkgPyBkZWxCYXNlUGF0aChwcmVmbGlnaHQucmV3cml0ZSkgOiBwcmVmbGlnaHQucmV3cml0ZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBmc1BhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXJzZWQucGF0aG5hbWUpO1xuICAgICAgICAgICAgbGV0IG1hdGNoZWRQYWdlO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFBhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZiA9IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZiA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgb3B0aW9ucy5wYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkSHJlZiAhPT0gcGFyc2VkLnBhdGhuYW1lICYmIG9wdGlvbnMucGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUGFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmV3cml0ZScsXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBwYXJzZWQucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZCxcbiAgICAgICAgICAgICAgICBtYXRjaGVkUGFnZSxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZsaWdodC5yZWRpcmVjdCkge1xuICAgICAgICAgICAgaWYgKHByZWZsaWdodC5yZWRpcmVjdC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhblJlZGlyZWN0ID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoaGFzQmFzZVBhdGgocHJlZmxpZ2h0LnJlZGlyZWN0KSA/IGRlbEJhc2VQYXRoKHByZWZsaWdodC5yZWRpcmVjdCkgOiBwcmVmbGlnaHQucmVkaXJlY3QsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgY2xlYW5SZWRpcmVjdCwgY2xlYW5SZWRpcmVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgbmV3VXJsLFxuICAgICAgICAgICAgICAgICAgICBuZXdBc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdCcsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IHByZWZsaWdodC5yZWRpcmVjdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgU1NSIHJlcXVlc3RzLCB0aGV5IHdpbGwgYmUgaGFuZGxlZCBsaWtlIG5vcm1hbCBwYWdlcy5cbiAgICAgICAgaWYgKHByZWZsaWdodC5yZWZyZXNoICYmICFwcmVmbGlnaHQuc3NyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWZyZXNoJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ25leHQnXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQcmVmbGlnaHREYXRhKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IHByZWZsaWdodEhyZWYgLCBzaG91bGRDYWNoZSA9ZmFsc2UgIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKHByZWZsaWdodEhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgIXRoaXMuaXNQcmV2aWV3ICYmIHNob3VsZENhY2hlICYmIHRoaXMuc2RlW2NhY2hlS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNkZVtjYWNoZUtleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaChwcmVmbGlnaHRIcmVmLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICd4LW1pZGRsZXdhcmUtcHJlZmxpZ2h0JzogJzEnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHJlZmxpZ2h0IHJlcXVlc3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6IHJlcy5oZWFkZXJzLmdldCgnTG9jYXRpb24nKSxcbiAgICAgICAgICAgICAgICByZWZyZXNoOiByZXMuaGVhZGVycy5oYXMoJ3gtbWlkZGxld2FyZS1yZWZyZXNoJyksXG4gICAgICAgICAgICAgICAgcmV3cml0ZTogcmVzLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtcmV3cml0ZScpLFxuICAgICAgICAgICAgICAgIHNzcjogISFyZXMuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1zc3InKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2RlW2NhY2hlS2V5XSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkZVtjYWNoZUtleV07XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwKTtcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscykubG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIHtcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFib3J0Q29tcG9uZW50TG9hZChhcywgcm91dGVQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5jbGMpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jbGMoKTtcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub3RpZnkoZGF0YSwgcmVzZXRTY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG59XG5Sb3V0ZXIuZXZlbnRzID0gKDAsIF9taXR0KS5kZWZhdWx0KCk7XG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXREb21haW5Mb2NhbGUiLCJhZGRMb2NhbGUiLCJkZWxMb2NhbGUiLCJoYXNCYXNlUGF0aCIsImFkZEJhc2VQYXRoIiwiZGVsQmFzZVBhdGgiLCJpc0xvY2FsVVJMIiwiaW50ZXJwb2xhdGVBcyIsInJlc29sdmVIcmVmIiwiX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJyZXF1aXJlIiwiX3JvdXRlTG9hZGVyIiwiX2lzRXJyb3IiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2Rlbm9ybWFsaXplUGFnZVBhdGgiLCJfbm9ybWFsaXplTG9jYWxlUGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzRHluYW1pYyIsIl9wYXJzZVJlbGF0aXZlVXJsIiwiX3F1ZXJ5c3RyaW5nIiwiX3Jlc29sdmVSZXdyaXRlcyIsIl9yb3V0ZU1hdGNoZXIiLCJfcm91dGVSZWdleCIsIl9nZXRNaWRkbGV3YXJlUmVnZXgiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJiYXNlUGF0aCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJhZGRQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInBhdGhOb1F1ZXJ5SGFzaCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwic3Vic3RyIiwibGVuZ3RoIiwibG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0ZWRMb2NhbGUiLCJkZXRlY3RlZERvbWFpbiIsInVuZGVmaW5lZCIsImh0dHAiLCJkb21haW4iLCJkZWZhdWx0TG9jYWxlIiwicGF0aExvd2VyIiwidG9Mb3dlckNhc2UiLCJsb2NhbGVMb3dlciIsInF1ZXJ5SW5kZXgiLCJpbmRleE9mIiwiaGFzaEluZGV4Iiwic3Vic3RyaW5nIiwic2xpY2UiLCJ1cmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJfIiwicm91dGUiLCJhc1BhdGhuYW1lIiwicXVlcnkiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImdldFJvdXRlUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZ3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJwYXJhbXMiLCJrZXlzIiwiZXZlcnkiLCJwYXJhbSIsInJlcGVhdCIsIm9wdGlvbmFsIiwicmVwbGFjZWQiLCJBcnJheSIsImlzQXJyYXkiLCJyZXBsYWNlIiwibWFwIiwic2VnbWVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJyZXN1bHQiLCJvbWl0UGFybXNGcm9tUXVlcnkiLCJmaWx0ZXJlZFF1ZXJ5IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicm91dGVyIiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsIm5vcm1hbGl6ZWRVcmwiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJhc1BhdGgiLCJmaW5hbFVybCIsImludGVycG9sYXRlZEFzIiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwiaGFzaCIsInJlc29sdmVkSHJlZiIsIl8xIiwic3RyaXBPcmlnaW4iLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVkQXMiLCJocmVmSGFkT3JpZ2luIiwiYXNIYWRPcmlnaW4iLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwic29tZSIsInBhZ2UiLCJyZSIsInRlc3QiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwib3B0cyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJ0aGVuIiwicmVzIiwib2siLCJzdGF0dXMiLCJqc29uIiwiZGF0YSIsIm5vdEZvdW5kIiwidGV4dCIsImZldGNoTmV4dERhdGEiLCJkYXRhSHJlZiIsImlzU2VydmVyUmVuZGVyIiwiaW5mbGlnaHRDYWNoZSIsInBlcnNpc3RDYWNoZSIsImxvY2F0aW9uIiwiY2FjaGVLZXkiLCJlcnIiLCJtYXJrQXNzZXRFcnJvciIsIlJvdXRlciIsImluaXRpYWxQcm9wcyIsInBhZ2VMb2FkZXIiLCJBcHAiLCJ3cmFwQXBwIiwiQ29tcG9uZW50Iiwic3Vic2NyaXB0aW9uIiwiaXNGYWxsYmFjayIsImlzUHJldmlldyIsInNkYyIsInNkciIsInNkZSIsIl9pZHgiLCJvblBvcFN0YXRlIiwiZSIsInN0YXRlIiwiY2hhbmdlU3RhdGUiLCJnZXRVUkwiLCJfX04iLCJmb3JjZWRTY3JvbGwiLCJvcHRpb25zIiwiaWR4IiwiSlNPTiIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwicGFyc2UiLCJwYXJzZVJlbGF0aXZlVXJsIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiY29tcG9uZW50cyIsInJlZiIsImluaXRpYWwiLCJwcm9wcyIsIl9fTl9TU0ciLCJfX05fU1NQIiwiX19OX1JTQyIsIl9fbmV4dF9yc2NfXyIsInN0eWxlU2hlZXRzIiwiZXZlbnRzIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJfX05FWFRfREFUQV9fIiwiYXV0b0V4cG9ydCIsInN1YiIsImNsYyIsIl93cmFwQXBwIiwiaXNSZWFkeSIsImdzc3AiLCJnaXAiLCJhcHBHaXAiLCJnc3AiLCJzZWFyY2giLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiaXNMb2NhbGVEb21haW4iLCJob3N0bmFtZSIsIl9zaG91bGRSZXNvbHZlSHJlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JvbGxSZXN0b3JhdGlvbiIsInJlbG9hZCIsImJhY2siLCJtZXRob2QiLCJzaG91bGRSZXNvbHZlSHJlZiIsIl9oIiwicHJldkxvY2FsZSIsInBhcnNlZEFzIiwibG9jYWxlUGF0aFJlc3VsdCIsImRpZE5hdmlnYXRlIiwiYXNOb0Jhc2VQYXRoIiwiUHJvbWlzZSIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwicm91dGVQcm9wcyIsIl9pbkZsaWdodFJvdXRlIiwiYWJvcnRDb21wb25lbnRMb2FkIiwiY2xlYW5lZEFzIiwibG9jYWxlQ2hhbmdlIiwib25seUFIYXNoQ2hhbmdlIiwiZW1pdCIsInNjcm9sbFRvSGFzaCIsIm5vdGlmeSIsInBhcnNlZCIsImFsbCIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsImdldE1pZGRsZXdhcmVMaXN0IiwicmV3cml0ZXMiLCJfX3Jld3JpdGVzIiwidXJsSXNOZXciLCJyZXdyaXRlc1Jlc3VsdCIsInAiLCJtYXRjaGVkUGFnZSIsIl9wcmVmbGlnaHRSZXF1ZXN0IiwiY2FjaGUiLCJlZmZlY3QiLCJ0eXBlIiwibmV3QXMiLCJuZXdVcmwiLCJkZXN0aW5hdGlvbiIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwic2hvdWxkSW50ZXJwb2xhdGUiLCJtaXNzaW5nUGFyYW1zIiwiZmlsdGVyIiwid2FybiIsImdldFJvdXRlSW5mbyIsInJvdXRlSW5mbyIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJwYXJzZWRIcmVmIiwiX19OX1BSRVZJRVciLCJmZXRjaENvbXBvbmVudCIsIm5vdEZvdW5kUm91dGUiLCJyZWYxIiwic3RhdHVzQ29kZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJzaG91bGRTY3JvbGwiLCJfc2Nyb2xsIiwic2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJzZXQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJsb2FkRXJyb3JGYWlsIiwiaXNBc3NldEVycm9yIiwiZ2V0SW5pdGlhbFByb3BzIiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJleGlzdGluZ1JvdXRlSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsIm1vZCIsImlzVmFsaWRFbGVtZW50VHlwZSIsImdldERhdGFIcmVmIiwic3NnIiwicnNjIiwiX2dldERhdGEiLCJfZ2V0RmxpZ2h0RGF0YSIsImZyZXNoIiwiX19mbGlnaHRfc2VyaWFsaXplZF9fIiwiX19mbGlnaHRfZnJlc2hfXyIsImNiIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJzY3JvbGxUbyIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJlZmZlY3RzIiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsImNhbmNlbCIsImhhbmRsZUNhbmNlbGxlZCIsImxvYWRQYWdlIiwiY29tcG9uZW50UmVzdWx0IiwiZm4iLCJyZXNvbHZlIiwic2VyaWFsaXplZCIsImZucyIsInJlcXVpcmVzUHJlZmxpZ2h0IiwibWlkZGxld2FyZSIsImlzU1NSIiwiZ2V0TWlkZGxld2FyZVJlZ2V4IiwiX2dldFByZWZsaWdodERhdGEiLCJwcmVmbGlnaHRIcmVmIiwic2hvdWxkQ2FjaGUiLCJwcmVmbGlnaHQiLCJyZXdyaXRlIiwiZnNQYXRobmFtZSIsInJlZGlyZWN0IiwiY2xlYW5SZWRpcmVjdCIsInJlZnJlc2giLCJzc3IiLCJoZWFkZXJzIiwiZ2V0IiwiaGFzIiwiY3R4IiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n");

/***/ })

});